/****************************************************************************************
 * FileName     : rl_sensor.h
 *
 * Description  : This file defines the functions to configure RF/Sensor in mmwave radar device.
 *
 ****************************************************************************************
 * (C) Copyright 2014, Texas Instruments Incorporated. - TI web address www.ti.com
 *---------------------------------------------------------------------------------------
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *    Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  OWNER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT,  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/****************************************************************************************
* FILE INCLUSION PROTECTION
****************************************************************************************
*/
#ifndef RL_SENSOR_H
#define RL_SENSOR_H

/******************************************************************************
 * INCLUDE FILES
 ******************************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************************
 * MACRO DEFINITIONS
 ****************************************************************************************
 */

/* Count of Test Sources*/
#define RL_MAX_TST_SRC_OBJECTS        (2U)

/* Number of chunks in Calibration data generated by radarSS */
#define RL_MAX_CALIB_DATA_CHUNK       (3U)

/*! \brief
* Supported maximum number of RX channels
*/
#define RL_RX_CNT                     (4U)

/*! \brief
* Supported maximum number of TX channels
*/
#define RL_TX_CNT                     (3U)

/*! \brief
* Enable/Disable RX/TX Channels
*/
#define RL_CHANNEL_DISABLE            (0U)
#define RL_CHANNEL_ENABLE             (1U)

/*! \brief
* Start/Stop Frame Trigger constants
*/
#define RL_FRAME_TRIGGER_STOP         (0x0U)
#define RL_FRAME_TRIGGER_START        (0x1U)

/*! \brief
* Supported maximum number of subframes in a frame
*/
#define RL_MAX_SUBFRAMES              (4U)

/*! \brief
* Supported maximum number of chirp profiles
*/
#define RL_MAX_PROFILES_CNT          (4U)

/*! \brief
* Supported noise figure modes
*/
#define RL_RX_NOISE_FIGURE_LOW        (0U)
#define RL_RX_NOISE_FIGURE_HIGH       (1U)
#define RL_RX_NOISE_FIGURE_MAX        (2U)

/*! \brief
* Supported ADC data bitwidths
*/
#define RL_ADC_DATA_12_BIT            (0U)
#define RL_ADC_DATA_14_BIT            (1U)
#define RL_ADC_DATA_16_BIT            (2U)
#define RL_ADC_DATA_BIT_MAX           (3U)

/*! \brief
* Supported ADC modes of operation
*/
#define RL_ADC_FORMAT_REAL                      (0U)
#define RL_ADC_FORMAT_COMPLEX_1X                (1U)
#define RL_ADC_FORMAT_COMPLEX_2X                (2U)
#define RL_ADC_FORMAT_PSEUDO_REAL               (3U)
#define RL_ADC_FORMAT_MAX                       (4U)

/*! \brief
* Supported ADC modes of operation
*/
#define RL_ADC_MODE_REGULAR                     (0U)
#define RL_ADC_MODE_LOW_POWER                   (1U)
#define RL_ADC_MODE_MAX                         (2U)

/*! \brief
* Supported Rx baseband bandwidths
*/
#define RL_RX_BB_BW_AUTO                        (0x0U)
#define RL_RX_BB_BW_350_KHz                     (0x1U)
#define RL_RX_BB_BW_10_MHz                      (0x2U)
#define RL_RX_BB_BW_15_MHz                      (0x3U)
#define RL_RX_BB_BW_MAX                         (0x4U)

/*! \brief
* Supported HPF-1 corner frequencies
*/
#define RL_RX_HPF1_175_KHz                      (0U)
#define RL_RX_HPF1_235_KHz                      (1U)
#define RL_RX_HPF1_350_KHz                      (2U)
#define RL_RX_HPF1_700_KHz                      (3U)
#define RL_RX_HPF1_MAX                          (4U)

/*! \brief
* Supported HPF-2 corner frequencies
*/
#define RL_RX_HPF2_350_KHz                      (0U)
#define RL_RX_HPF2_700_KHz                      (1U)
#define RL_RX_HPF2_1p4_MHz                      (2U)
#define RL_RX_HPF2_2p8_MHz                      (3U)
#define RL_RX_HPF2_5p0_MHz                      (4U)
#define RL_RX_HPF2_7p5_MHz                      (5U)
#define RL_RX_HPF2_10_MHz                       (6U)
#define RL_RX_HPF2_15_MHz                       (7U)
#define RL_RX_HPF2_MAX                          (8U)

/*! \brief
* Supported Rx gains
*/
#define RL_RX_GAIN_30_dB                        (0x1EU)
#define RL_RX_GAIN_36_dB                        (0x24U)
#define RL_RX_GAIN_44_dB                        (0x2cU)
#define RL_RX_GAIN_50_dB                        (0x32U)

/*! \brief
* Supported frame sync modes
*/
#define RL_FRAME_SYNC_MODE_SINGLE_CHIP          (0x0U)
#define RL_FRAME_SYNC_MODE_MULT_CHIP_MASTER     (0x1U)
#define RL_FRAME_SYNC_MODE_MULT_CHIP_SLAVE      (0x2U)
#define RL_FRAME_SYNC_MODE_MAX                  (0x3U)


/*! \brief
* Supported frame start trigger modes
*/
#define RL_FRAMESTRT_API_TRIGGER                (0x1U)
#define RL_FRAMESTRT_SYNCIN_TRIGGER             (0x2U)

/*! \brief
* Supported Rx analog configurations
*/
#define RL_RXANA_COMPLEX                        (0U)
#define RL_RXANA_REAL                           (1U)
#define RL_RXANA_MODES_MAX                      (2U)

/*! \brief
* Supported Temperature Sensor Range in step of 10C
*/
#define RL_MAX_NUM_OF_TEMP10_RANGES             (19U)

/*! \brief
* Supported LUT parameter index for Advanced Chirp configuration
*/
#define RL_LUT_CHIRP_PROFILE_VAR                (0x0U)
#define RL_LUT_CHIRP_FREQ_START_VAR             (0x1U)
#define RL_LUT_CHIRP_FREQ_SLOPE_VAR             (0x2U)
#define RL_LUT_CHIRP_IDLE_TIME_VAR              (0x3U)
#define RL_LUT_CHIRP_ADC_START_TIME_VAR         (0x4U)
#define RL_LUT_CHIRP_TX_EN_VAR                  (0x5U)
#define RL_LUT_CHIRP_BPM_VAL_VAR                (0x6U)
#define RL_LUT_TX0_PHASE_SHIFT_VAR              (0x7U)
#define RL_LUT_TX1_PHASE_SHIFT_VAR              (0x8U)
#define RL_LUT_TX2_PHASE_SHIFT_VAR              (0x9U)

/*! \brief
* Maximum chunk size for Advanced chirp LUT data per SPI message
*/
#define RL_MAX_ADV_CHIRP_LUT_CHUNK_SIZE         (212U)

/******************************************************************************
 * GLOBAL VARIABLES/DATA-TYPES DEFINITIONS
 ******************************************************************************
 */

/*! \brief
* Rx/Tx Channel Configuration
*/
typedef struct rlChanCfg
{
    /**
     * @ brief  RX Channel Bitmap \n
                b0 RX0 Channel Enable \n
                0   Disable RX Channel 0 \n
                1   Enable RX Channel 0 \n
                b1 RX1 Channel Enable \n
                0   Disable RX Channel 1 \n
                1   Enable RX Channel 1 \n
                b2 RX2 Channel Enable \n
                0   Disable RX Channel 2 \n
                1   Enable RX Channel 2 \n
                b3 RX3 Channel Enable \n
                0   Disable RX Channel 3 \n
                1   Enable RX Channel 3 \n
                b15:4 - RESERVED \n
     */
    rlUInt16_t rxChannelEn;
    /**
     * @brief  TX Channel Bitmap \n
                b0 TX0 Channel Enable \n
                0   Disable TX Channel 0 \n
                1   Enable TX Channel 0\n
                b1 TX1 Channel Enable \n
                0   Disable TX Channel 1 \n
                1   Enable TX Channel 1 \n
                b2 TX2 Channel Enable \n
                0   Disable TX Channel 2 \n
                1   Enable TX Channel 2 \n
                b15:3 - RESERVED \n
                @note : TX2 is supported only on some of the devices, Please refer device data \n
                        sheet. \n
     */
    rlUInt16_t txChannelEn;
    /**
     * @brief  Enable Cascading \n
                 0x0000 SINGLECHIP: Single mmWave sensor application\n
                 0x0001 MULTICHIP_MASTER: Multiple mmwave sensor application. This mmwave is \n
                 the master chip and generates LO and conveys to other mmwave sensor. \n
                 This is applicable only in AWR2243/xWR6243.\n
                 0x0002 MULTICHIP_SLAVE: Multiple mmwave sensor application. This mmwave is a \n
                 slave chip and uses LO conveyed to it by the master mmwave sensor. \n
                 This is applicable only in AWR2243/xWR6243 \n
                 @note : Please refer device data sheet for cascading capability and 20G SYNC
                         pins \n
     */
    rlUInt16_t cascading;
    /**
     * @brief  Cascading pinout config \n
     *         b0 - CLKOUT_MASTER_DIS \n
     *              0 - 20G FM_CW_CLKOUT from master is enabled \n
     *              1 - 20G FM_CW_CLKOUT from master is disabled \n
     *         b1 - SYNCOUT_MASTER_DIS \n
     *              0 - 20G FM_CW_SYNCOUT from master is enabled \n
     *              1 - 20G FM_CW_SYNCOUT from master is disabled \n
     *         b2 - CLKOUT_SLAVE_EN \n
     *              0 - 20G FM_CW_CLKOUT from slave is disabled \n
     *              1 - 20G FM_CW_CLKOUT from slave is enabled \n
     *         b3 - SYNCOUT_SLAVE_EN \n
     *              0 - 20G FM_CW_SYNCOUT from slave is disabled \n
     *              1 - 20G FM_CW_SYNCOUT from slave is enabled \n
     *         b4 - INTLO_MASTER_EN \n
     *              0 - Master uses looped back LO \n
     *              1 - Master uses internal LO \n
     *         b5 - OSCCLKOUT_DIS \n
     *              By default OSC CLK is enabled at device powerup, that can be disabled using \n
     *              this option.  \n
     *              0 - Enable OSCCLKOUT \n
     *              1 - Disable OSCCLKOUT \n
     *        @note : This feature is supported only on AWR2243/xWR6243 device. It is
     *                recommended to disable the OSC clock when the device is configured
     *                in SINGLE_CHIP or SLAVE mode.  \n
     *         b6 - INTFRC_MASTER_EN \n
     *              Applicable only in MULTICHIP_MASTER device. \n
     *              Default value is 0.  \n
     *              0 - Use externally looped back FRC SyncIn \n
     *              1 - Use internal FRC SyncIn in master \n
     *      b15:7 - RESERVED \n
     */
    rlUInt16_t cascadingPinoutCfg;
}rlChanCfg_t;

/*! \brief
* ADC Bit and ADC Output format Configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlAdcBitFormat
{
    /**
     * @brief  ADC out bits - 0(12 Bits), 1(14 Bits), 2(16 Bits)
     */
    rlUInt32_t b2AdcBits           :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b6Reserved0        :6;
    /**
     * @brief Number of bits to reduce ADC full scale by
               Valid range: 0 to (16 - Number of ADC bits)
               For e.g. for 12 bit ADC output, this field can take values 0, 1, 2 or 3 \n
               For 14 bit ADC output, this field can take values 0, 1 or 2 \n
               For 16 bit ADC output, this field can take only value 0 \n
      */
    rlUInt32_t b8FullScaleReducFctr:8;
    /**
     * @brief  ADC out format- 0(Real), 1(Complex), 2(Complex with Image band), 3(Pseudo Real)
     */
    rlUInt32_t b2AdcOutFmt         :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b14Reserved1        :14;
}rlAdcBitFormat_t;
#else
typedef struct rlAdcBitFormat
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b14Reserved1        :14;
    /**
     * @brief  ADC out format- 0(Real), 1(Complex), 2(Complex with Image band), 3(Pseudo Real)
     */
    rlUInt32_t b2AdcOutFmt         :2;
    /**
     * @brief Number of bits to reduce ADC full scale by
               Valid range: 0 to (16 - Number of ADC bits)
               For e.g. for 12 bit ADC output, this field can take values 0, 1, 2 or 3 \n
               For 14 bit ADC output, this field can take values 0, 1 or 2 \n
               For 16 bit ADC output, this field can take only value 0 \n
      */
    rlUInt32_t b8FullScaleReducFctr:8;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b6Reserved0        :6;
    /**
     * @brief  ADC out bits - 0(12 Bits), 1(14 Bits), 2(16 Bits)
     */
    rlUInt32_t b2AdcBits           :2;
}rlAdcBitFormat_t;
#endif

/*! \brief
* ADC format and payload justification Configuration
*/
typedef struct rlAdcOutCfg
{
    /**
     * @brief  ADC Data format
     */
    rlAdcBitFormat_t fmt;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
}rlAdcOutCfg_t;


/*! \brief
* Binary phase modulation mode configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlBpmModeCfg
{
    /**
     * @brief  BPM_SRC_SEL (select source of BPM pattern) \n
                   00 CHIRP_CONFIG_BPM (refer to rlBpmChirpCfg_t\n
                   01 RESERVED \n
                   10 RESERVED \n
                   11 RESERVED \n
     */
    rlUInt16_t b2SrcSel           :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b1Reserved0        :1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b13Reserved1       :13;
}rlBpmModeCfg_t;
#else
typedef struct rlBpmModeCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b13Reserved1       :13;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b1Reserved0        :1;
    /**
     * @brief  BPM_SRC_SEL (select source of BPM pattern) \n
                   00 CHIRP_CONFIG_BPM (refer to rlBpmChirpCfg_t\n
                   01 RESERVED \n
                   10 RESERVED \n
                   11 RESERVED  \n
     */
    rlUInt16_t b2SrcSel           :2;
}rlBpmModeCfg_t;
#endif

/*! \brief
* Binary phase modulation KCounter configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlBpmKCounterSel
{
    /**
     * @brief  K Counter Start Select (Reserved for future)
     */
    rlUInt16_t b1BpmKStart        :1;
    /**
     * @brief  K Counter End Select (Reserved for future)
     */
    rlUInt16_t b1BpmKEnd          :1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b14Reserved        :14;
}rlBpmKCounterSel_t;
#else
typedef struct rlBpmKCounterSel
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b14Reserved        :14;
    /**
     * @brief  K Counter End Select (Reserved for future)
     */
    rlUInt16_t b1BpmKEnd          :1;
    /**
     * @brief  K Counter Start Select (Reserved for future)
     */
    rlUInt16_t b1BpmKStart        :1;
}rlBpmKCounterSel_t;
#endif

/*! \brief
* Binary phase modulation common configuration
*/
typedef struct rlBpmCommonCfg
{
    /**
     * @brief  BPM Mode configuration
     */
    rlBpmModeCfg_t mode;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt32_t reserved3;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt32_t reserved4;
}rlBpmCommonCfg_t;

/*! \brief
* Binary phase modulation common configuration
*/
typedef struct rlBpmChirpCfg
{
    /**
     * @brief  Chirp Start Index, Valid Range 0 -511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp End Index, Valid Range from chirpStartIdx to 511
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief        b0  RESERVED \n
                     b1  CONST_BPM_VAL_TX0_TXON \n
                     Value of Binary Phase Shift value for TX0, during chirp \n
                     b2  RESERVED \n
                     b3  CONST_BPM_VAL_TX1_TXON \n
                     Value of Binary Phase Shift value for TX1, during chirp \n
                     b4  RESERVED \n
                     b5  CONST_BPM_VAL_TX2_TXON \n
                     Value of Binary Phase Shift value for TX2, during chirp \n
                     b15:6 Reserved \n
     */
    rlUInt16_t constBpmVal;
    /**
     * @brief  Reserved for future
     */
    rlUInt16_t reserved;
}rlBpmChirpCfg_t;

/*! \brief
* Low Power mode configuration
*/
typedef struct rlLowPowerModeCfg
{
    /**
     * @brief  Reserved for future
     */
    rlUInt16_t reserved;
    /** ADC Mode \n
     * @brief  0x00 : Regular ADC mode \n
               0x01 : Low poer ADC mode \n
     */
    rlUInt16_t lpAdcMode;
}rlLowPowerModeCfg_t;

/*! \brief
* Profile config API parameters. A profile contains coarse parameters of FMCW chirp such as
* start frequency, chirp slope, ramp time, idle time etc. Fine dithering values need
* to be programmed in chirp configuration \ref rlChirpCfg_t
* \note Maximum of 4 profiles can be configured.
*/
typedef struct rlProfileCfg
{
    /**
     * @brief  Profile index (0-3)
     */
    rlUInt16_t profileId;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Bit Description  \n
                b0 FORCE_VCO_SEL (Not supported for production in xWR6243 , debug purpose only) \n
                 0 - Use internal VCO selection    \n
                 1 - Forced external VCO selection \n
                b2:1 VCO_SEL (Not supported for production in xWR6243 , debug purpose only) \n
                 0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                 1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)  \n
                 2 - VCO3 (77G:Reserved. Set it to 0b0. For xWR6243: 56-58 GHz)  \n
                 @note 1: xWR1xxx devices: There is an overlap region of 77-78 GHz in which any \n
                          of the VCOs can be used, for other regions use only the VCO which can \n
                          work in that region. For e.g. for 76-78 GHz use only VCO1 and for \n
                          77-81GHz use only VCO2, for 77-78 GHz, any VCO can be used. Also note \n
                          that users can inter-mix chirps from different VCOs within the same \n
                          frame.
                 @note 2: xWR6x43 device: There is an overlap region of 60-60.75 GHz in which \n
                          any of the VCOs can be used. \n
                 @note 3: AWR2243 device: VCO2 range is 76 - 81GHz (5GHz RF Bandwidth). There \n
                          is an overlap region of 76-78 GHz in which any of the VCOs can be \n
                          used \n
                 @note 4: xWR6243 device: VCO3 is available only on selected xWR6243 device \n
                          variants. There is an overlap region of 57-58 GHz in which VCO1 \n
                          or VCO3 can be used. \n
                b7:3 RESERVED            \n
     */
    rlUInt8_t pfVcoSelect;
    /**
     * @brief Bit Description       \n
               b0 RETAIN_TXCAL_LUT \n
                0 - Update TX calibration LUT           \n
                1 - Do not update TX calibration LUT    \n
               b1 RETAIN_RXCAL_LUT \n
                0 - Update RX calibration LUT and update RX IQMM correction \n
                1 - Do not update RX calibration LUT    \n
               b7:2 RESERVED                            \n
               Normally, whenever Profile Config API is issued, the TX/RX analog settings are 
               recomputed and their properties can change. If Profile Config API is issued for a 
               second time then the user has an option to ensure the TX/RX RF properties/settings 
               are unchanged, by setting the appropriate RETAIN_RX/TXCAL_LUT bits to 1. \n
               For example, if Profile Config API is issued with minor timing parameter changes 
               like Idle Time and without changing the TX power or RX gain or chirp RF frequency 
               range, then the RETAIN_RX/TXCAL_LUTs can be set to ensure that only the timing 
               parameters change without disturbing the RF analog properties. \n
     */
    rlUInt8_t pfCalLutUpdate;
#else
    /**
     * @brief Bit Description       \n
               b0 RETAIN_TXCAL_LUT \n
                0 - Update TX calibration LUT           \n
                1 - Do not update TX calibration LUT    \n
               b1 RETAIN_RXCAL_LUT \n
                0 - Update RX calibration LUT and update RX IQMM correction \n
                1 - Do not update RX calibration LUT    \n
               b7:2 RESERVED                            \n
               Normally, whenever Profile Config API is issued, the TX/RX analog settings are 
               recomputed and their properties can change. If Profile Config API is issued for a 
               second time then the user has an option to ensure the TX/RX RF properties/settings 
               are unchanged, by setting the appropriate RETAIN_RX/TXCAL_LUT bits to 1. \n
               For example, if Profile Config API is issued with minor timing parameter changes 
               like Idle Time and without changing the TX power or RX gain or chirp RF frequency 
               range, then the RETAIN_RX/TXCAL_LUTs can be set to ensure that only the timing 
               parameters change without disturbing the RF analog properties. \n
     */
    rlUInt8_t pfCalLutUpdate;
    /**
     * @brief  Bit Description  \n
                b0 FORCE_VCO_SEL (Not supported for production in xWR6243 , debug purpose only) \n
                 0 - Use internal VCO selection    \n
                 1 - Forced external VCO selection \n
                b2:1 VCO_SEL (Not supported for production in xWR6243 , debug purpose only) \n
                 0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                 1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)  \n
                 2 - VCO3 (77G:Reserved. Set it to 0b0. For xWR6243: 56-58 GHz)  \n
                 @note 1: xWR1xxx devices: There is an overlap region of 77-78 GHz in which any \n
                          of the VCOs can be used, for other regions use only the VCO which can \n
                          work in that region. For e.g. for 76-78 GHz use only VCO1 and for \n
                          77-81GHz use only VCO2, for 77-78 GHz, any VCO can be used. Also note \n
                          that users can inter-mix chirps from different VCOs within the same \n
                          frame.
                 @note 2: xWR6x43 device: There is an overlap region of 60-60.75 GHz in which \n
                          any of the VCOs can be used. \n
                 @note 3: AWR2243 device: VCO2 range is 76 - 81GHz (5GHz RF Bandwidth). There \n
                          is an overlap region of 76-78 GHz in which any of the VCOs can be \n
                          used \n
                 @note 4: xWR6243 device: VCO3 is available only on selected xWR6243 device \n
                          variants. There is an overlap region of 57-58 GHz in which VCO1 \n
                          or VCO3 can be used. \n
                b7:3 RESERVED            \n
     */
    rlUInt8_t pfVcoSelect;
#endif
    /**
     * @brief  Start frequency for each profile \n
                  For 77GHz devices (76 GHz - 81 GHz): \n
                      1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz  \n
                      Valid range: 0x5471C71B to 0x5A000000 \n
                  For 60GHz devices (56 GHz/57 GHz - 64 GHz): \n
                      1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz  \n
                      Valid range: Only even numbers from 0x52F684BD/0x5471C71C to 0x5ED097B4 \n
       @note : Refer to device datasheet for supported frequency ranges 
     */
    rlUInt32_t startFreqConst;
    /**
     * @brief  Idle time\n
                  1 LSB = 10 ns \n
                  Valid range: 0 to 524287 \n
     */
    rlUInt32_t idleTimeConst;
    /**
     * @brief  Time of starting of ADC capture relative to the knee of the ramp\n
                  1 LSB = 10 ns \n
                  Valid range: 0 to 4095 \n
     */
    rlUInt32_t adcStartTimeConst;
    /**
     * @brief  End of ramp time relative to the knee of the ramp\n
                   1 LSB = 10 ns\n
                   Valid range: 0 to 500000 \n
                   Ensure that the total frequency sweep is either within these ranges: \n
                   77G : 76 - 78 GHz or 77 - 81 GHz \n
                   60G : 56 - 58 GHz or 57 - 60.75 GHz or 60 - 64 GHz \n
                   @note : The actual ramping time for the chirp is 1LSB=10ns more than the value
                           programmed. \n
     */
    rlUInt32_t rampEndTime;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2\n
                   Bit    Description  \n
                   b7:0   TX0 output power back off \n
                   b15:8  TX1 output power back off \n
                   b23:16 TX2 output power back off \n
                   b31:24 Reserved \n
               This field defines how much the transmit power should be reduced from the maximum \n
               1 LSB = 1 dB \n
               Valid Range for AWR2243 devices: 0 to 20 \n
               Valid Range for xWR6x43 devices: 0 to 26 \n
               0dB back-off corresponds to typically 13dBm power level in AWR2243/xWR6x43 device \n
               @note 1: Tx output power is more accurate when the programmed Tx backoff is
                        close to 0dB. \n
               @note 2: For best inter-TX channel matching performance, same chirp profile and \n
                       same TX backoff value should be used for all the TXs that are used in \n
                       beam-forming \n
     */
    rlUInt32_t txOutPowerBackoffCode;
    /**
     * @brief  Concatenated phase shift for TX0/1/2,\n
                   Bit       Description \n
                   b1:0      Reserved (set to 0b00) \n
                   b7:2      TX0 phase shift value \n
                   b9:8      Reserved (set to 0b00) \n
                   b15:10    TX1 phase shift value \n
                   b17:16    Reserved (set to 0b00) \n
                   b23:18    TX2 phase shift value \n
                   b31:24    Reserved \n
                   1 LSB = 360/2^6 = 5.625 degrees \n
               This field defines the additional phase shift to be introduced on each \n
               transmitter output.
               @note : Chirps corresponding to different profiles are not guaranteed to have \n
                       phase coherency.
     */
    rlUInt32_t txPhaseShifter;
    /**
     * @brief  Ramp slope frequency, \n
                   For 77GHz devices (76GHz to 81GHz): \n
                       1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \n
                       Valid range: \n
                           AWR2243 device: -5510 to 5510 (266MHz/uS) \n
                   For 60GHz devices (57GHz to 64GHz): \n
                       1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS for 60GHz devices \n
                       Valid range: Only even numbers between -6905 to 6905 (Max 250 MHz/uS) \n
               @note : Refer \ref rlRfApllSynthBwControl_t bandwidth control API for \n
                       constraints on max slope. 0 slope can be used only for debug purposes. \n
     */
    rlInt16_t freqSlopeConst;
    /**
     * @brief  Time of start of transmitter relative to the knee of the ramp \n
                   1 LSB = 10ns \n
                   Valid range: -4096 to 4095 \n
     */
    rlInt16_t txStartTime;
    /**
     * @brief  Number of ADC samples to capture in a chirp for  each RX \n
               Valid range: 2 to MAX_NUM_SAMPLES\n
               Where MAX_NUM_SAMPLES is such that all the enabled RX channels' data fits \n
               into 16 kB memory memory in AWR1243/xWR1443/AWR2243/xWR6243 or 32 kB memory in \n
               xWR1642/xWR6x43/xWR1843, with each sample consuming 2 bytes for real ADC \n
               output case and 4 bytes for complex 1x and complex 2x ADC output cases. \n
               For example in AWR1243/xWR1443/AWR2243/xWR6243 when the ADC buffer size is 16 kB \n
                   number of RX chains    ADC format    Maximum Number of samples \n
                    4                      complex       1024 \n
                    4                      Real          2048 \n
                    2                      Complex       2048 \n
                    2                      Real          4096 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  ADC Sampling rate for each profile is encoded in \n
                   2 bytes (16 bit unsigned number) \n
                   1 LSB = 1 ksps \n
                   Valid range: \n
                   AWR2243/xWR6243 device: 2000 to 50000 (Max 20MHz IF bandwidth) \n
                   The maximum sampling rate supported is limited based on the information
                   below. \n
                   <table>
                   <caption id="IF_BW_20MHz">When device supports 20 MHz IF bandwidth (refer
                   device data sheet)</caption>
                   <tr><th>ADC mode   <th>Real/PseudoReal   <th>Complex1x   <th>Complex2x
                   <tr><td>Regular ADC mode<td>45 Msps<td>22.5 Msps<td>45 Msps
                   <tr><td>Low power ADC mode<td>18.75 Msps<td>9.375 Msps<td>18.75 Msps
                   </table>
                   <table>
                   <caption id="IF_BW_15MHz">When device supports 15 MHz IF bandwidth (refer
                   device data sheet)</caption>
                   <tr><th>ADC mode   <th>Real/PseudoReal   <th>Complex1x   <th>Complex2x
                   <tr><td>Regular ADC mode<td>37.5 Msps<td>18.75 Msps<td>37.5 Msps
                   <tr><td>Low power ADC mode<td>18.75 Msps<td>9.375 Msps<td>18.75 Msps
                   </table>
                   @note : In Low power ADC mode, the max supported IF BW is 7.5MHz only.
     */
    rlUInt16_t digOutSampleRate;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Code for HPF1 corner frequency\n
                   0x00 175 kHz \n
                   0x01 235 kHz \n
                   0x02 350 kHz \n
                   0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief  Code for HPF2 corner frequency\n
                   0x00 350 kHz \n
                   0x01 700 kHz \n
                   0x02 1.4 MHz \n
                   0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
#else
    /**
     * @brief  Code for HPF2 corner frequency\n
                   0x00 350 kHz \n
                   0x01 700 kHz \n
                   0x02 1.4 MHz \n
                   0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief  Code for HPF1 corner frequency\n
                   0x00 175 kHz \n
                   0x01 235 kHz \n
                   0x02 350 kHz \n
                   0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
#endif
    /**
     * @brief  Number of transmitters to turn on during TX power  \n
               calibration. During actual operation, if more than \n
               1 TXs are enabled during the chirp, then enabling  \n
               the same TXs during calibration will have better TX \n
               output power accuracy \n
                    b2:0 TX enabled during TX0 calibration \n
                         b0 - TX0, b1 - TX1, b2 - TX2 \n
                    b5:3 TX enabled during TX1 calibration \n
                         b3 - TX0, b4 - TX1, b5 - TX2 \n
                    b8:6 TX enabled during TX2 calibration \n
                         b6 - TX0, b7 - TX1, b8 - TX2 \n
                    b14:9 RESERVED \n
                    b15  Enable multi TX enable during TX power calibration. \n
                         @note 1: If this bit is not set, only 1 TX is enabled \n
                         during the TX power calibration. For e.g. during TX0 \n
                         calibration, only TX0 will be enabled; during TX1 \n
                         calibration, only TX1 will be enabled and so on. \n
     */
    rlUInt16_t txCalibEnCfg;
    /**
     * @brief
                b5:0  This field defines RX gain for each channel. \n
                      1 LSB = 1 dB \n
                      Valid values: \n
                      AWR2243 : All even values from 32 to 52 \n
                      xWR6x43 : All even values from 30 to 48 \n
                b7:6  Code for RF gain target \n
                      The RF gain target for AWR2243/xWR6x43 device:
                      Value      RF gain target
                      00         30 dB \n
                      01         33 dB \n
                      10         36 dB (Recommended) \n
                      11         RESERVED \n
                b15:8 RESERVED \n
    @note 1: The total RX gain is achieved as a sum of RF gain and IF amplifiers gain. The RF Gain
    Target (30 dB, 33 dB and 36 dB) allows the user to control the RF gain independently from the
    total RX gain, thus giving flexibility to the user to trade-off linearity vs. noise figure.
    Out of multiple gain settings for the RF stages, the firmware calibration algorithm uses the
    one that makes the RF gain as close as possible to the user programmed RF Gain Target. \n
    @note 2: At high temperatures, the RF Gain Targets provide trade-off of approximately 4 dB in 
    RF P1dB point vs 2 dB in noise figure. \n
    @note 3: For the lowest RF Gain Target setting 30 dB, the RF gain varies linearly from 38 dB at
    -40C to 30 dB at 140C for nominal process corner. Since the minimum IF gain is -6 dB, The 
    minimum achievable RX Gain varies from 32 dB at -40C to 24 dB at 140C. \n
    @note 4: The maximum RX gain setting is recommended to be limited to 48dB, which can be 
    achieved at all temperatures and RF gain target conditions. Increasing RX gain beyond 48 dB 
    may result in degradation of in-band P1dB without improvement in noise figure. \n
     */
    rlUInt16_t  rxGain;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
} rlProfileCfg_t;

/*! \brief
* Chirp config API parameters. This structure contains fine dithering to coarse profile
* defined in \ref rlProfileCfg_t. It also includes the selection of Transmitter and
* binary phase modulation for a chirp.\n
* @note : One can define upto 512 unique chirps.These chirps need to be included in
*         frame configuration structure \ref rlFrameCfg_t to create FMCW frame
*/
typedef struct rlChirpCfg
{
    /**
     * @brief  Chirp start index (0-511)
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp end index (0-511)
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief  Associated profile id (0-3)
     */
    rlUInt16_t profileId;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
    /**
     * @brief  Ramp start frequency, \n
               For 77GHz devices(76GHz to 81GHz): \n
                   1 LSB = 3.6e9/2^26 = 53.644 Hz \n
                   valid range = 0-8388607 \n
               For 60GHz devices(57GHz to 64GHz): \n
                   1 LSB = 2.7e9/2^26 = 40.233 Hz \n
                   valid range = Only even numbers from 0-8388607 \n
     */
    rlUInt32_t startFreqVar;
    /**
     * @brief  Ramp slope\n
               For 77GHz devices(76GHz to 81GHz): \n
                   1 LSB = 3.6e6 * 900/2^26 = 48.279 KHz/us \n
                   valid range = 0-63 \n
               For 60GHz devices(57GHz to 64GHz): \n
                   1 LSB = 2.7e6 * 900/2^26 = 36.21 KHz/us \n
                   valid range = Only even numbers from 0-63 \n
     */
    rlUInt16_t freqSlopeVar;
    /**
     * @brief  Idle time for each chirp\n
                   1 LSB = 10ns\n
                   valid range = 0-4096 \n
     */
    rlUInt16_t idleTimeVar;
    /**
     * @brief  Adc start time for each chirp \n
                   1 LSB = 10ns \n
                   valid range = 0-4096 \n
     */
    rlUInt16_t adcStartTimeVar;
    /**
     * @brief  Tx enable selection bit mask \n
                   b0 Enable TX0 \n
                   0 Tx0 Disable \n
                   1 Tx0 Enable \n
                   b1 Enable TX1 \n
                   0 Tx1 Disable \n
                   1 Tx1 Enable \n
                   b2 Enable TX2 \n
                   0 Tx2 Disable \n
                   1 Tx2 Enable  \n
                   @note : Maximum of only 2 TX can be turned in a chirp \n
     */
    rlUInt16_t txEnable;
}rlChirpCfg_t;

/*! \brief
* Chirp start, end Index parameters for rlGetChirpConfig
*/
typedef struct rlWordParam
{
    rlUInt16_t halfWordOne;
    rlUInt16_t halfWordTwo;
}rlWordParam_t;

/*! \brief
* Frame config API parameters
*/
typedef struct rlFrameCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Start Index of Chirp Valid range = 0-511
     *        @note : If ADVANCE_CHIRP_CONFIG_EN is set then this Field is not used/applicable. \n
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  End Index of Chirp Valid range = chirpStartIdx-511
     *        @note : If ADVANCE_CHIRP_CONFIG_EN is set then this Field is not used/applicable. \n
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief  Number of times to repeat from chirpStartIdx to chirpEndIdx in each frame, \n
     *             valid range = 1 to 255 \n
     *        @note : If ADVANCE_CHIRP_CONFIG_EN is set then this field definition is modified. \n
     *                ADVANCE_CHIRP_CONFIG mode: This field configures the total number of chirps 
     *                in a frame L. This should be programmed as per below calculation. \n
     *                L = X * Y, where X is 1 to 512 (HW RAM) and Y is 1 to 128 (HW loops) \n
     *                The value of L should be a multiple of 4 (assuming each chirp is min 25us
     *                duration) i.e 1, 4, 8, 12, 16, 20, 24 ¦ 32768 (max). \n
     *                The FW needs to prepare and update HW chirp RAM dynamically in advance chirp
     *                config API, this puts some restriction on minimum number of chirps in a
     *                burst/frame. \n
     *         Valid range 1 to 32768 \n
     */
    rlUInt16_t numLoops;
    /**
     * @brief  Number of frame to transmit \n
                Valid Range 0 to 65535 (0 for infinite frames) \n
     */
    rlUInt16_t numFrames;
    /**
     * @brief  Number of ADC samples to capture This parameter is required only for 
                AWR1243/AWR2243/xWR6243 and configures the size of ADC samples per chirp to be 
                sent on LVDS/CSI2 interface. \n
                It should be configured as:
                For real/pseudo real ADC data - numADCSamples = rlProfileCfg_t.numAdcSamples \n
                For complex1x/complex2x ADC data -  \n
                numADCSamples = (rlProfileCfg_t.numAdcSamples ) * 2 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  Frame repitition period \n
                  PERIOD >= Sum total time of all chirps + InterFrameBlankTime, 
                  where, Sum total time of all chirps = Num Loops * Num chirps * Chirp Period. \n
                  InterFrameBlankTime is primarily for sensor calibration/monitoring, thermal 
                  control, transferring out any safety monitoring data if requested, hardware 
                  reconfiguration for next frame, re-triggering of next frame. \n
                  InterFrameBlankTime >= 300 μs typically. \n
                  Add 150 us to InterFrameBlankTime if data-path reconfiguration needed in frame 
                  boundary due to change in profile. \n
                  1 LSB = 5 ns \n
                  Valid range : 300 us to 1.342 s \n
                  @note :  If the devices’ self-triggered periodic monitoring features are \n
                  enabled, the user needs to set the frame period taking into \n
                  consideration the monitoring periodicities \n
                  (refer to CALIB_MON_TIME_UNIT in AWR_CALIB_MON_TIME_UNIT_CONF_SB) \n
     */
    rlUInt32_t framePeriodicity;
    /**
     * @brief  Selects the mode for triggering start of transmission of frame \n
                   0x0001 SWTRIGGER (Software API based triggering): \n
                   Frame is triggered upon receiving rlSensorStart\n
                   There could be several tens of micro seconds uncertainty in triggering. \n
                   @note : This mode is not applicable if this mmwave device is configured as \n
                   MULTICHIP_SLAVE in rlChanCfg_t \n
                   0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \n
                   Each frame is triggered by rising edge of pulse in SYNC_IN pin, after
                   receiving rlSensorStart (this is to prevent spurious transmission).
                   W.r.t. the SYNC_IN pulse, the actual transmission has ~160ns delay and 5ns 
                   uncertainty in SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip
                   synchronization needed) in MULTICHIP sensor applications as defined in
                   rlChanCfg_t. \n
                   For more details please refer to device datasheet. \n
     */
    rlUInt16_t triggerSelect;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \n
                Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\n
                It is recommended only for staggering the transmission of multiple mmwave \n
                sensors around the car for interference avoidance, if needed.\n
                1 lsb = 5 ns \n
                Typical range is 0 to 100 micro seconds. \n
     */
    rlUInt32_t frameTriggerDelay;
}rlFrameCfg_t;

/*! \brief
 * Advance Frame config API Subframe configuration
 */
typedef struct rlSubFrameCfg
{
    /**
     * @brief  Force profile index. This is applicable only if FORCE_SINGLE_PROFILE is set to 1
     */
    rlUInt16_t forceProfileIdx;
    /**
     * @brief  Start index of the first chirp for the first burst in sub frame. \n
     *         Valid range: 0 to 511 \n
     *         This field is not applicable for loop-back sub-frame. \n
     *         @note : If ADVANCE_CHIRP_CONFIG_EN is set then this field is not used/applicable. \n
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Number of unique chirps per burst. \n
     *         Valid range: 1 to 512 \n
     *         This field is not applicable for loop-back sub-frame. \n
     *         @note : If ADVANCE_CHIRP_CONFIG_EN is set then this field is not used/applicable. \n
     */
    rlUInt16_t numOfChirps;
    /**
     * @brief  No. of times to loop through the unique chirps in each burst, without gaps, \n
                   using HW.\n valid range = 1 to 255 \n
               @note : If ADVANCE_CHIRP_CONFIG_EN is set then this Field definition is modified. \n
               ADVANCE_CHIRP_CONFIG mode: This field configures the total number of chirps in a 
               burst L. This should be programmed as per below calculation. \n
               L = X * Y, where X is 1 to 512 (HW RAM) and Y is 1 to 128 (HW loops) \n
               The value of L should be a multiple of 4 (assuming each chirp is min 25us duration)
               i.e 1, 4, 8, 12, 16, 20, 24 ¦ 32768 (max). The FW needs to prepare and update HW
               chirp RAM dynamically in advance chirp config API, this puts some restriction on
               minimum number of chirps in a burst/frame. \n
               Valid range 1 to 32768 \n
     */
    rlUInt16_t numLoops;
    /**
     * @brief  burstPeriodicity >= (numLoops)* (sum total of all unique chirp times per burst) +
                InterBurstBlankTime, \n
                where InterBurstBlankTime is primarily for sensor calibration / monitoring, \n
                thermal control, and some minimum time needed for triggering next burst. \n
                InterBurstBlankTime >= 110 us. Refer a NOTE at end of this API for more info. \n
                With loop back enabled, InterBurstBlankTime >= 500 us \n
                @note : Across bursts, if the value numOfChirps, is not a constant, then the \n
                actual available blank time can vary and needs to be accounted for \n
                1 LSB = 5 ns \n
                Valid range: 55 uS to 1.342 sec \n
     */
    rlUInt32_t burstPeriodicity;
    /**
     * @brief  Chirp Start address increment for next burst, \n
                   next_burst_chirp_start_idx = last_chirp_end_index + \n
                   h_ChirpStartIdxIncr 0 - 511, 0 = 2nd burst = 1st burst \n
              @note : If ADVANCE_CHIRP_CONFIG_EN is set then this Field is not used/applicable. \n
     */
    rlUInt16_t chirpStartIdxOffset;
    /**
     * @brief  Num of bursts in the sub-frame. Valid Range: 1 - 512 \n
     *         Valid range: 1 to 16 for loop-back sub-frame \n
     */
    rlUInt16_t numOfBurst;
    /**
     * @brief  Number of times to loop over the set of above defined bursts, in the sub frame. \n
                    Valid Range: 1 - 64 \n
                    This field is not applicable for loop-back sub-frame \n
     */
    rlUInt16_t numOfBurstLoops;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  subFramePeriodicity >= Sum total time of all bursts + InterSubFrameBlankTime, \n
                 Where, Sum total time of all bursts = numOfBurstLoops * numOfBurst * \n
                 burstPeriodicity. \n
                 InterSubFrameBlankTime is primarily for sensor calibration / monitoring, \n
                 thermal control, transferring out any safety monitoring data if requested, \n
                 hardware reconfiguration for next sub frame, re-triggering of next SF (~10us). \n
                 The hardware reconfiguration time, which is needed to transfer out the SF's \n
                 InterSubFrameBlankTime 300 us. \n
                 Add 150 us to InterSubFrameBlankTime if data-path re-configuration needed in
                 sub-frame boundary due to change in profile. \n
                 1 LSB = 5 ns \n
                 Valid range 300 us to 1.342 s. \n
     */
    rlUInt32_t subFramePeriodicity;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved2;
}rlSubFrameCfg_t;

/*! \brief
 * Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes
 */
typedef struct rlAdvFrameSeqCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of sub frames enabled in this frame Valid range: 1 to 4
     */
    rlUInt8_t          numOfSubFrames;
    /**
     * @brief  Force profile. \n
                0x0 The profile index set in rlSetChirpConfig API governs which profile is \n
                used when that chirp is transmitted \n
                0x1 The profile index indicated in rlSetChirpConfig API is ignored and all \n
                the chirps in each sub frame use a single profile as indicated by that sub \n
                frame's profile forceProfileIdx. \n
                @note : This Field is not used/applicable for loop-back sub-frame. \n
     */
    rlUInt8_t          forceProfile;
    /**
     * @brief Bit  Definition \n
              b0   LOOPBACK_CFG_EN \n
                    0 - Disable \n
                    1 - Enable  \n
              b2:1  SUB_FRAME_ID for which the loop-back configuration applies \n
              b7:3  RESERVED \n
     */
    rlUInt8_t          loopBackCfg;
    /**
     * @brief  Sub frame trigger
     *              0 - Disabled (default mode, i.e no trigger is required in SW triggered mode \n
     *                  and a pulse trigger is required every burst start) \n
     *              1 - Enabled (Need to trigger each sub-frame either by SW in \n
     *                  software triggered mode through AWR_SUBFRAME_START_CONF_SB API or \n
     *                  HW pulse in hardware triggered mode) \n
     *                  @note : Disable WDT if this mode is enabled.
     */
    rlUInt8_t          subFrameTrigger;
#else
    /**
     * @brief  Force profile.
                0x0 The profile index set in rlSetChirpConfig API governs which profile is \n
                used when that chirp is transmitted \n
                0x1 The profile index indicated in rlSetChirpConfig API is ignored and all \n
                the chirps in each sub frame use a single profile as indicated by that sub \n
                frame's profile forceProfileIdx. \n
                @note : This Field is not used/applicable for loop-back sub-frame. \n
     */
    rlUInt8_t          forceProfile;
    /**
     * @brief  Number of sub frames enabled in this frame Valid range: 1 to 4
     */
    rlUInt8_t          numOfSubFrames;
    /**
     * @brief  Sub frame trigger
     *              0 - Disabled (default mode, i.e no trigger is required in SW triggered mode \n
     *                  and a pulse trigger is required every burst start) \n
     *              1 - Enabled (Need to trigger each sub-frame either by SW in \n
     *                  software triggered mode through AWR_SUBFRAME_START_CONF_SB API or \n
     *                  HW pulse in hardware triggered mode) \n
     *                  @note : Disable WDT if this mode is enabled.
     */
    rlUInt8_t          subFrameTrigger;
    /**
     * @brief Bit  Definition \n
              b0   LOOPBACK_CFG_EN \n
                    0 - Disable \n
                    1 - Enable  \n
              b2:1  SUB_FRAME_ID for which the loop-back configuration applies \n
              b7:3  RESERVED \n
     */
    rlUInt8_t          loopBackCfg;
#endif
    /**
     * @brief  Subframe config for 4 sub frames
     */
    rlSubFrameCfg_t    subFrameCfg[RL_MAX_SUBFRAMES];
    /**
     * @brief  Number of frames to transmit (1 frame = all enabled sub frames). If set to 0, \n
                frames are transmitted endlessly till Frame Stop message is received.\n
                Valid range: 0 to 65535 \n
     */
    rlUInt16_t         numFrames;
    /**
     * @brief  Selects the mode for triggering start of transmission of frame \n
                 0x0001 SWTRIGGER (Software API based triggering): \n
                   Frame is triggered upon receiving rlSensorStart There could be several tens \n
                   of micro seconds uncertainty in triggering. \n
                   @note :This mode is not applicable if this mmwave device is configured as \n
                   MULTICHIP_SLAVE in rlChanCfg_t \n
                 0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \n
                   Each frame is triggered by rising edge of pulse in SYNC_IN pin, after \n
                   receiving rlSensorStart (this is to \n prevent spurious transmission). \n
                   W.r.t. the SYNC_IN pulse, the actual transmission has 5ns uncertainty in \n
                   SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip \n
                   synchronization needed) in MULTICHIP sensor applications as defined in \n
                   rlChanCfg_t. \n
     */
    rlUInt16_t         triggerSelect;
    /**
     * @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \n
                Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\n
                It is recommended only for staggering the transmission of multiple mmwave \n
                sensors around the car for interference avoidance, if needed. \n
                1 lsb = 5 ns \n
                Typical range is 0 to few tens of micro seconds. \n
     */
    rlUInt32_t         frameTrigDelay;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t         reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t         reserved1;
}rlAdvFrameSeqCfg_t;


/*! \brief
* Frame config API parameters
*/
typedef struct rlFrameApplyCfg
{
    /**
     * @brief  Number of Chirps per Frame
     */
    rlUInt32_t numChirps;
    /**
     * @brief  Number of half words in ADC buffer per chirp \n
                Example 1:  In real mode, if number of ADC samples per chirp is 256 then this \n
                value will be 256 \n
                Example 2: In complex1x or complex2x modes,if number of ADC samples per chirp \n
                is 256 then this value will be 512 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlFrameApplyCfg_t;

/*! \brief
* Sub Frame data config API parameters
*/
typedef struct rlSubFrameDataCfg
{
    /**
     * @brief  Number of Chirps in Sub-Frame = numOfChirps * numLoops * numOfBurst * burstLoop
     */
    rlUInt32_t totalChirps;
    /**
     * @brief  Number of half words of ADC samples per data packet in sub frame 1 \n
                Example 1:  In real mode, if number of ADC samples per chirp in subframe1 is
                256 then this value will be 256 \n
                Example 2: In complex1x or complex2x modes, if number of ADC samples per
                chirp in subframe1 is 256 then this value will be 512 \n
                In AWR2243/AWR1243/xWR1443/xWR6243: Program this as number of ADC samples in each 
                chirp of this sub frame (required to be the same) \n
                Exception: Can do number of chirps based ping-pong as in xWR1642
                (see below), if CP/CQ are not needed. Useful for chirp stitching use case. \n
                In xWR1642/xWR1843(For reference only): The ADC samples corresponding to one or
                more chirps can be grouped and sent to the DSP as a single packet. Program this
                as the number of half words of ADC samples per packet. Ensure that in one sub
                frame, there is integer number of such packets. \n
                Maximum size of a data packet: (16384 - 1) half words
     */
    rlUInt16_t numAdcSamples;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of Chirps Per Data Packet to process at a time in sub frame 1. \n
                In AWR2243/AWR1243/xWR1443/xWR6243: Program this as 1. \n
                Exception: Can be > 1 as in 16xx if CP/CQ is not needed. Useful for chirp
                stitching use case. \n
                In xWR1642/xWR1843(For reference only): The ADC samples corresponding to one or
                more chirps can be grouped and sent to the DSP as a single packet. Program this
                as the corresponding number of chirps per packet. \n
                Maximum value = 8. \n
                Note on maximum size: 8 chirps for CP and BPM.
     */
    rlUInt8_t numChirpsInDataPacket;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  Number of Chirps Per Data Packet to process at a time in sub frame 1. \n
                In AWR2243/AWR1243/xWR1443/xWR6243: Program this as 1. \n
                Exception: Can be > 1 as in 16xx if CP/CQ is not needed. Useful for chirp
                stitching use case.\n
                In xWR1642/xWR1843: The ADC samples corresponding to one or more chirps can be
                grouped and sent to the DSP as a single packet. Program this as the
                corresponding number of chirps per packet. \n
                Maximum value = 8. \n
                Note on maximum size: 8 chirps for CP and BPM. \n
     */
    rlUInt8_t numChirpsInDataPacket;
#endif
}rlSubFrameDataCfg_t;

/*! \brief
* Advance Frame data config API parameters.
* This structure is only applicable when mmWaveLink instance is running on
* External Host and connected to AWR1243/AWR2243/xWR6243 device.
*/
typedef struct rlAdvFrameDataCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of Sub Frames, Valid Range (1 - 4)
     */
    rlUInt8_t numSubFrames;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved0;
    /**
     * @brief  Number of Sub Frames, Valid Range (1 - 4)
     */
    rlUInt8_t numSubFrames;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Sub Frame data configuration array.
     */
    rlSubFrameDataCfg_t subframeDataCfg[RL_MAX_SUBFRAMES];
}rlAdvFrameDataCfg_t;

/*! \brief
 * Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes
 */
typedef struct rlAdvFrameCfg
{
    /**
     * @brief  Advance Frame sequence and Subframe configuration
     */
    rlAdvFrameSeqCfg_t frameSeq;
    /**
     * @brief  Advance Frame data configuration. Applicable with AWR1243/AWR2243/xWR6243 devices
     */
    rlAdvFrameDataCfg_t frameData;
}rlAdvFrameCfg_t;

/*! \brief
* Continous Mode config API parameters
*/
typedef struct rlContModeCfg
{
    /**
     * @brief  Start frequency \n
               For 77GHz devices (76 - 81 GHz): \n
                  1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \n
                  Valid range: 0x5471C71B to 0x5A000000 \n
               For 60GHz devices (56 GHz/57 GHz - 64 GHz): \n
                  1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \n
                  Valid range: Only even numbers from 0x5471C71C to 0x5ED097B4 \n
       @note : Refer to device datasheet for supported frequency ranges
     */
    rlUInt32_t startFreqConst;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2 \n
                b7:0 TX0 output power back off \n
                b15:8 TX1 output power back off \n
                b23:16 TX2 output power back off \n
                b31:24 Reserved \n
                This field defines how much the transmit power should be reduced from the \n
                maximum. \n
                1 LSB = 1 dB \n
     */
    rlUInt32_t txOutPowerBackoffCode;
    /**
     * @brief  Concatenated phase shift for TX0/1/2, \n
                Bit       Description \n
                b1:0      Reserved (set to 0b00) \n
                b7:2      TX0 phase shift value \n
                b9:8      Reserved (set to 0b00) \n
                b15:10    TX1 phase shift value \n
                b17:16    Reserved (set to 0b00) \n
                b23:18    TX2 phase shift value \n
                b31:24    Reserved \n
                1 LSB = 360/2^6 = 5.625 degrees \n
                This field defines the additional phase shift to be introduced on each \n
                transmitter output. \n
     */
    rlUInt32_t txPhaseShifter;
    /**
     * @brief  ADC Sampling rate for each profile is encoded in \n
                2 bytes (16 bit unsigned number) \n
                1 LSB = 1 ksps \n
                Valid range 2000 to 37500 \n
     */
    rlUInt16_t digOutSampleRate;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Code for HPF1 corner frequency \n
                0x00 175 kHz \n
                0x01 235 kHz \n
                0x02 350 kHz \n
                0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief  Code for HPF2 corner frequency \n
                0x00 350 kHz \n
                0x01 700 kHz \n
                0x02 1.4 MHz \n
                0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief This field defines RX gain for continuous streaming mode. \n
                b5:0  This field defines RX gain for each channel. \n
                      1 LSB = 1 dB \n
                      Valid values: \n
                      AWR2243 : All even values from 32 to 52 \n
                      xWR6x43 : All even values from 30 to 48 \n
                b7:6  Code for RF gain target \n
                      The RF gain target for AWR2243/xWR6x43 device:
                      Value      RF gain target
                      00         30 dB \n
                      01         33 dB \n
                      10         36 dB (Recommended) \n
                      11         RESERVED \n
                b15:8 RESERVED \n
     */
    rlUInt8_t  rxGain;
    /**
     * @brief Bit   Description
                b0  FORCE_VCO_SEL(Not supported for production in xWR6243 , debug purpose only) \n
                    0 - Use internal VCO selection
                    1 - Forced external VCO selection
                b2:1  VCO_SEL
                    0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                    1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)  \n
                    2 - VCO3 (77G:Reserved. Set it to 0b0. For xWR6243: 56-58 GHz)  \n
                b7:3    RESERVED
       @note: xWR6243 device: VCO3 is available only on selected device xWR6243 device variants. \n
     */
    rlUInt8_t vcoSelect;
#else
    /**
     * @brief  Code for HPF2 corner frequency \n
                0x00 350 kHz \n
                0x01 700 kHz \n
                0x02 1.4 MHz \n
                0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief  Code for HPF1 corner frequency \n
                0x00 175 kHz \n
                0x01 235 kHz \n
                0x02 350 kHz \n
                0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief Bit   Description
                b0  FORCE_VCO_SEL(Not supported for production in xWR6243 , debug purpose only) \n
                    0 - Use internal VCO selection
                    1 - Forced external VCO selection
                b2:1  VCO_SEL
                    0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                    1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)  \n
                    2 - VCO3 (77G:Reserved. Set it to 0b0. For xWR6243: 56-58 GHz)  \n
                b7:3    RESERVED
       @note: xWR6243 device: VCO3 is available only on selected device xWR6243 device variants. \n
     */
    rlUInt8_t vcoSelect;
    /**
     * @brief This field defines RX gain for continuous streaming mode. \n
                b5:0  This field defines RX gain for each channel. \n
                      1 LSB = 1 dB \n
                      Valid values: \n
                      AWR2243 : All even values from 32 to 52 \n
                      xWR6x43 : All even values from 30 to 48 \n
                b7:6  Code for RF gain target \n
                      The RF gain target for AWR2243/xWR6x43 device:
                      Value      RF gain target
                      00         30 dB \n
                      01         33 dB \n
                      10         36 dB (Recommended) \n
                      11         RESERVED \n
                b15:8 RESERVED \n
     */
    rlUInt8_t  rxGain;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlContModeCfg_t;

/*! \brief
* Continous Mode Enable API parameters
*/
typedef struct rlContModeEn
{
    /**
     * @brief  Enable continuous steaming mode \n
                0x00 Disable continuous streaming mode \n
                0x01 Enable continuous streaming mode \n
     */
    rlUInt16_t contModeEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlContModeEn_t;

/*! \brief
* Frame Trigger API parameters RL_RF_FRAMESTARTSTOP_CONF_SB
*/
typedef struct rlFrameTrigger
{
    /**
      * @brief  Start/Stop Frame \n
                 0x0000 - Stop the transmission of frames after the current frame \n
                 0x0001 - Trigger a frame in software triggered mode. In hardware SYNC_IN triggered
                          mode, this command allows subsequent SYNC_IN trigger to be honored \n
                 0x0002 - Stop the transmission of frames after the current sub-frame is over at 
                          sub-frame boundary \n
                 0x0003 - Stop the transmission of frames after the current burst is over at burst 
                          boundary \n
                 0x0004 - Stop the transmission of frames immediately which are waiting for HW 
                          trigger or sub-frame trigger (applicable only for HW/sub-frame triggered 
                          mode when active frames are not running or HW pulse are not provided.) \n
     */
    rlUInt16_t startStop;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlFrameTrigger_t;


/*! \brief
* The Object position and signal strength parameter structure
*/
typedef struct rlTestSourceObject
{
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                X position of object 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posX;
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                Y position of object 1lsb = 1cm, 0 -32767 cm \n
     */
    rlInt16_t posY;
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                Z position of object 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZ;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                X velocity of object 1lsb = 1 cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velX;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                Y velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velY;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                Z velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velZ;
    /**
     * @brief  Reflecting obj' sig level at ADC o/p, relative to ADC Full Scale \n
                1 LSB = -0.1 dBFS, Valid Range 0 to 950 \n
     */
    rlUInt16_t sigLvl;
    /**
     * @brief  Boundary min limit, Obj location resets to posX if cross boundary \n
                X position of min boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posXMin;
    /**
     * @brief  Boundary min limit, Obj location resets to posY if cross boundary \n
                Y position of min boundary 1lsb = 1cm, 0 to 32767cm \n
     */
    rlInt16_t posYMin;
    /**
     * @brief  Boundary min limit, Obj location resets to posZ if cross boundary \n
                Z position of min boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZMin;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                X position of max boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posXMax;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                Y position of max boundary 1lsb = 1cm, 0 to 32767cm \n
     */
    rlInt16_t posYMax;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                Z position of max boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZMax;
}rlTestSourceObject_t;

/*! \brief
* The Antenna position parameter structure
*/
typedef struct rlTestSourceAntPos
{
    /**
     * @brief  Antenna position X 1lsb=wavelength/8 Valid range = +/-15 wave lengths
     */
    rlInt8_t  antPosX;
    /**
     * @brief  Antenna position Z 1lsb=wavelength/8 Valid range = +/-15 wave lengths
     */
    rlInt8_t  antPosZ;
}rlTestSourceAntPos_t;

/*! \brief
* Test source config API parameters E_API_AR_TEST_SOURCE_CONF_SB
*/
typedef struct rlTestSource
{
    /**
     * @brief  Arary of test Objects
     */
    rlTestSourceObject_t   testObj[RL_MAX_TST_SRC_OBJECTS];
    /**
     * @brief  Simulated Position of Rx Antennas
     */
    rlTestSourceAntPos_t   rxAntPos[RL_RX_CNT];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Miscellaneous control functionality. \n
               Bits     Dither \n
               b0       value  Definition \n
                        0      Dither is enabled in test source \n
                        1      Dither is disabled in test source \n
               @note : This feature is supported only on AWR2243/xWR6243 device. \n
               b7:1     Reserved \n
     */
    rlUInt8_t  miscFunCtrl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
    /**
     * @brief  Miscellaneous control functionality. \n
               Bits     Dither \n
               b0       value  Definition \n
                        0      Dither is enabled in test source \n
                        1      Dither is disabled in test source \n
               @note : This feature is supported only on AWR2243/xWR6243 device. \n
               b7:1     Reserved \n
     */
    rlUInt8_t  miscFunCtrl;
#endif
}rlTestSource_t;

/*! \brief
* Test source Enable API parameters RL_RF_TEST_SOURCE_ENABLE_SB
*/
typedef struct rlTestSourceEn
{
    /**
     * @brief  Test source Enable - 1, Disable - 0
     */
    rlUInt16_t  tsEnable;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved;
}rlTestSourceEnable_t;

/*! \brief
* RF characterization Time and Temperature data structure
*/
typedef struct rlRfTempData
{
    /**
     * @brief  radarSS local Time from device powerup. 1 LSB = 1 ms
     */
    rlUInt32_t time;
    /**
     * @brief  RX0 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpRx0Sens;
    /**
     * @brief  RX1 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpRx1Sens;
    /**
     * @brief  RX2 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpRx2Sens;
    /**
     * @brief  RX3 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpRx3Sens;
    /**
     * @brief  TX0 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpTx0Sens;
    /**
     * @brief  TX1 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpTx1Sens;
    /**
     * @brief  TX2 temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpTx2Sens;
    /**
     * @brief  PM temperature sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpPmSens;
    /**
     * @brief  Digital temp sensor reading (signed value). 1 LSB = 1 deg C
     */
    rlInt16_t tmpDig0Sens;
    /**
     * @brief  Second digital temp sensor reading (signed value).( applicable only in \n
     *         xWR1642/xWR6843/xWR1843.) \n
     *         1 LSB = 1 deg C \n
     */
    rlInt16_t tmpDig1Sens;
}rlRfTempData_t;

/*! \brief
* The DFE Statistics for Rx Channel for particular profile
*/
typedef struct rlDfeRxdStatReport
{
    /**
     * @brief  Average DC value in I chain for profile x, RX channel x
     */
    rlInt16_t   iAvgDC;
    /**
     * @brief  Average DC value in Q chain for profile x, RX channel x
     */
    rlInt16_t   qAvgDC;
    /**
     * @brief  Average power in I chain for profile x, RX channel x
     */
    rlUInt16_t  iAvgPwr;
    /**
     * @brief  Average power in Q chain for profile x, RX channel x
     */
    rlUInt16_t  qAvgPwr;
    /**
     * @brief  Average cross correlation between I and Q chains for profile x, RX channel x
     */
    rlInt32_t   iqAvgCroCorrel;
} rlDfeRxStatReport_t;

/*! \brief
* The DFE Statistics Report Contents
*/
typedef struct rlDfeStatReport
{
    /**
     * @brief Contain DFE statistic report for all profile and receiver
     */
    rlDfeRxStatReport_t dfeStatRepo[RL_MAX_PROFILES_CNT][RL_RX_CNT];
}rlDfeStatReport_t;

/*! \brief
* Dynamic power saving API parameters
*/
typedef struct rlDynPwrSave
{
    /**
     * @brief  Enable dynamic power saving during inter-chirp IDLE times by \n
     *          turning off various circuits e.g. TX, RX, LO. 3 LSB is vaild \n
     *          b0 Enable power save by switching off TX  during inter-chirp IDLE period \n
     *             0    Disable \n
     *             1    Enable \n
     *          b1 Enable power save by switching off RX  during inter-chirp IDLE period \n
     *             0    Disable \n
     *             1    Enable \n
     *          b2 Enable power save by switching off LO distribution  during inter-chirp IDLE\n
     *          period \n
     *             0    Disable \n
     *             1    Enable \n
     */
    rlUInt16_t blkCfg;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
} rlDynPwrSave_t;

/*! \brief
* API RF device Config SBC M_API_AR_RF_DEV_CONF_SBC
*/
typedef struct rlRfDevCfg
{
    /**
     * @brief Bit Definition \n
     *        b1:0 Global Async event direction \n
     *             00 - radarSS to MSS   01 - radarSS to HOST\n
     *             10 - radarSS to DSS   11 - RESERVED   \n
     *             The ASYNC_EVENT_DIR controls the direction for following ASYNC_EVENTS \n
     *             [1.] CPU_FAULT [2.] ESM_FAULT [3.] ANALOG_FAULT \n
     *             All other ASYNC_EVENTs are sent to the subsystem which issues the API \n
     *        b3:2 Monitoring Async Event direction
     *             00 - radarSS to MSS   01 - radarSS to HOST\n
     *             10 - radarSS to DSS   11 - RESERVED   \n
     *        b31:4 Reserved
     */
    rlUInt32_t aeDirection;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief Bit Definition \n
     *       b0: FRAME_START_ASYNC_EVENT_DIS        \n
     *           0 Frame Start async event enable   \n
     *           1 Frame Start async event disable  \n
     *       b1: FRAME_STOP_ASYNC_EVENT_DIS         \n
     *           0 Frame Stop async event enable    \n
     *           1 Frame Stop async event disable   \n
     *       b7:2 Reserved
     */
    rlUInt8_t       aeControl;
    /**
     * @brief  Bit   Definition \n
     *         b0    INTER_BURST_POWER_SAVE_DIS \n
     *               0 Inter burst power save enable (default) \n
     *               1 Inter burst power save disable (Applicable only in single chip usecase) \n
     *               Default value: 0
     *               This disable feature is applicable only in single chip use case. In case of 
     *               cascade slave device, synth power down is done by default. \n
     *               This allows to disable inter burst power save feature for individual 
     *               bursts in a advance frame config API to reduce inter-burst idle time
     *               requirement. The power save is done always in inter sub-frame and 
     *               frame boundaries irrespective of this control bit configuration. \n
     *               The inter burst power save needs extra 55us burst idle time, please refer 
     *               Table \ref interBurstTime for more details on inter burst time. \n
     *         b7:1  Reserved \n    
     */
    rlUInt8_t       bssAnaControl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved1;
    /**
     * @brief Bit Definition \n
     *       b0: WDT_ENABLE        \n
     *           0 Keep watchdog disabled   \n
     *           1 Enable watch dog  \n
     *       b7:1: Reserved \n
     *       @note :The Windowed WDT can be enabled only in SW triggered framing Mode or in \n
     *              cascade mode where frames of all the devices synchronized with same clock \n
     *              source, if frames are triggered from Hw trigger pulse generated from \n
     *              unsynchronized clock then WDT can not be enabled. \n
     *       @note 2: WDT shall be disabled if API based monitoring trigger is enabled in 
     *                MONITORING_MODE in AWR_CALIB_MON_TIME_UNIT_CONF_SB. \n
     *       @note 3: WDT shall be disabled if SUB_FRAMETRIGGER mode is enabled in 
     *                AWR_ADVANCED_FRAME_CONF_SB API. \n
     */
    rlUInt8_t       bssDigCtrl;
    /**
     * @brief CRC Config for Asynchornous event message \n
     *          Value  Description \n
     *           0     16 bit CRC for radarSS async events \n
     *           1     32 bit CRC for radarSS async events \n
     *           2     64 bit CRC for radarSS async events \n
     *
     */
    rlUInt8_t aeCrcConfig;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved2;
#else
    /**
     * @brief  Bit   Definition \n
     *         b0    INTER_BURST_POWER_SAVE_DIS \n
     *               0 Inter burst power save enable (default) \n
     *               1 Inter burst power save disable (Applicable only in single chip usecase) \n
     *               Default value: 0
     *               This disable feature is applicable only in single chip use case. In case of 
     *               cascade slave device, synth power down is done by default. \n
     *               This allows to disable inter burst power save feature for individual 
     *               bursts in a advance frame config API to reduce inter-burst idle time
     *               requirement. The power save is done always in inter sub-frame and 
     *               frame boundaries irrespective of this control bit configuration. \n
     *               The inter burst power save needs extra 55us burst idle time, please refer 
     *               Table \ref interBurstTime for more details on inter burst time. \n
     *         b7:1  Reserved \n    
     */
    rlUInt8_t       bssAnaControl;
    /**
     * @brief Bit Definition \n
     *       b0: FRAME_START_ASYNC_EVENT_DIS        \n
     *           0 Frame Start async event enable   \n
     *           1 Frame Start async event disable  \n
     *       b1: FRAME_STOP_ASYNC_EVENT_DIS         \n
     *           0 Frame Stop async event enable    \n
     *           1 Frame Stop async event disable
     */
     rlUInt8_t       aeControl;
    /**
     * @brief Bit Definition \n
     *       b0: WDT_ENABLE        \n
     *           0 Keep watchdog disabled   \n
     *           1 Enable watch dog  \n
     *       b7:1: Reserved \n
     *       @note :The Windowed WDT can be enabled only in SW triggered framing Mode or in \n
     *              cascade mode where frames of all the devices synchronized with same clock \n
     *              source, if frames are triggered from Hw trigger pulse generated from \n
     *              unsynchronized clock then WDT can not be enabled. \n
     *       @note 2: WDT shall be disabled if API based monitoring trigger is enabled in 
     *                MONITORING_MODE in AWR_CALIB_MON_TIME_UNIT_CONF_SB. \n
     *       @note 3: WDT shall be disabled if SUB_FRAMETRIGGER mode is enabled in 
     *                AWR_ADVANCED_FRAME_CONF_SB API. \n
     */
    rlUInt8_t       bssDigCtrl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved2;
    /**
     * @brief CRC Config for Asynchornous event message \n
     *          Value  Description \n
     *           0     16 bit CRC for radarSS async events \n
     *           1     32 bit CRC for radarSS async events \n
     *           2     64 bit CRC for radarSS async events \n
     *
     */
    rlUInt8_t aeCrcConfig;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t       reserved3;
} rlRfDevCfg_t;

/*! \brief
*  Num of samples to collect for API GPADC sensors
*  sampleCnt    : Number of samples to collect @625KHz
*/
typedef struct rlGpAdcSamples
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of samples to collect
     */
    rlUInt8_t sampleCnt;
    /**
     * @brief  Number of samples to skip before collecting the data
     *         1 LSB = 0.8 us, Valid range: 0 to 12 us
     */
    rlUInt8_t settlingTime;
#else
    /**
     * @brief  Number of samples to skip before collecting the data
     *         1 LSB = 0.8 us, Valid range: 0 to 12 us
     */
    rlUInt8_t settlingTime;
    /**
     * @brief  Number of samples to collect
     */
    rlUInt8_t sampleCnt;
#endif
}rlGpAdcSamples_t;

/*! \brief
* API radarSS GPADC API MEAS SET SBC M_API_AR_RF_GPADC_API_SET_SB
*/
typedef struct rlGpAdcCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable different sensors \n
                [b0] 1: ANATEST1 Enable,  0: ANATEST1 Disable \n
                [b1] 1: ANATEST2 Enable,  0: ANATEST2 Disable \n
                [b2] 1: ANATEST3 Enable,  0: ANATEST3 Disable \n
                [b3] 1: ANATEST4 Enable,  0: ANATEST4 Disable \n
                [b4] 1: ANAMUX   Enable,  0: ANAMUX   Disable \n
                [b5] 1: VSENSE   Enable,  0: VSENSE   Disable \n
                [b7:6]   Reserved \n
     */
    rlUInt8_t        enable;
    /**
     * @brief  Enable buffer for each input \n
                [b0] 1: ANATEST1 buffer enable,  0: ANATEST1 buffer disable \n
                [b1] 1: ANATEST2 buffer enable,  0: ANATEST2 buffer disable \n
                [b2] 1: ANATEST3 buffer enable,  0: ANATEST3 buffer disable \n
                [b3] 1: ANATEST4 buffer enable,  0: ANATEST4 buffer disable \n
                [b4] 1: ANAMUX   buffer enable,  0: ANAMUX   buffer disable \n
                [b7:5]   Reserved \n
    */
    rlUInt8_t        bufferEnable;
#else
    /**
     * @brief  Enable buffer for each input \n
                [b0] 1: ANATEST1 buffer enable,  0: ANATEST1 buffer disable \n
                [b1] 1: ANATEST2 buffer enable,  0: ANATEST2 buffer disable \n
                [b2] 1: ANATEST3 buffer enable,  0: ANATEST3 buffer disable \n
                [b3] 1: ANATEST4 buffer enable,  0: ANATEST4 buffer disable \n
                [b4] 1: ANAMUX   buffer enable,  0: ANAMUX   buffer disable \n
                [b7:5]   Reserved \n
    */
    rlUInt8_t        bufferEnable;
    /**
     * @brief  Enable different sensors \n
                [b0] 1: ANATEST1 Enable,  0: ANATEST1 Disable \n
                [b1] 1: ANATEST2 Enable,  0: ANATEST2 Disable \n
                [b2] 1: ANATEST3 Enable,  0: ANATEST3 Disable \n
                [b3] 1: ANATEST4 Enable,  0: ANATEST4 Disable \n
                [b4] 1: ANAMUX   Enable,  0: ANAMUX   Disable \n
                [b5] 1: VSENSE   Enable,  0: VSENSE   Disable \n
                [b7:6]   Reserved \n
     */
    rlUInt8_t        enable;
#endif
    /**
     * @brief  Configure number of sample to be \n
                collected for each sensor This array of numOfSamples is for the sensors \n
                which are enabled in above parameter 'enable' \n
     */
    rlGpAdcSamples_t  numOfSamples[RL_MAX_GPADC_SENSORS];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t        reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t        reserved1[3U];
} rlGpAdcCfg_t;

/*! \brief
* Radar RF LDO bypass enable/disable configuration
*/
typedef struct rlRfLdoBypassCfg
{
    /**
     * @brief  Enable LDO bypass \n
                [b0] 1: RF LDO bypassed, Should be used only when 1.0V RF supply is provided
                     0: RF LDO not bypassed(default), Should be used only when 1.3V RF supply
                     is provided \n
                [b1] 0: PA LDO input is enabled\n
                     1: PA LDO input is disabled (3 TX use case).
                        (To be used only when VIN_RF2 is shorted to VOUT_PA on board and VIN_RF2 is
                         1.0V) \n
                [b15:2] Reserved \n
                usecase                                            LDO bypass    PA LDO disable \n
                1.3V RF supply 1 and 1.3V RF supply 2                 0               0
                1.0V RF supply 1 and 1.0V RF supply 2                 1               0
                1.0V RF supply 1 and 1.0V RF supply 2                 1               1
                     and RF supply 1 shorted to Vout PA

     */
    rlUInt16_t ldoBypassEnable;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  IR drop is the voltage drop from the PMIC output to the device pin. The user
               should program the voltage drop in percentage units which will be used for
               measuring the external supplies.  \n
                Value  Description   \n
                0      IR drop of 0% \n
                1      IR drop of 3% \n
                2      IR drop of 6% \n
                3      IR drop of 9% \n
     */
    rlUInt8_t supplyMonIrDrop;
    /**
     * @brief  IO supply indicator. This is used to indicate the IO supply to the MMIC device
     *         for setting the correct voltage monitor thresholds
     *         Value   Description \n
     *          0      3.3 V IO supply \n
     *          1      1.8 V IO supply \n
     */
    rlUInt8_t ioSupplyIndicator;
#else
    /**
     * @brief  IO supply indicator. This is used to indicate the IO supply to the MMIC device
     *         for setting the correct voltage monitor thresholds
     *         Value   Description \n
     *          0      3.3 V IO supply \n
     *          1      1.8 V IO supply \n
     */
    rlUInt8_t ioSupplyIndicator;
    /**
     * @brief  IR drop is the voltage drop from the PMIC output to the device pin. The user
               should program the voltage drop in percentage units which will be used for
               measuring the external supplies.  \n
                Value  Description   \n
                0      IR drop of 0% \n
                1      IR drop of 3% \n
                2      IR drop of 6% \n
                3      IR drop of 9% \n
     */
    rlUInt8_t supplyMonIrDrop;
#endif
}rlRfLdoBypassCfg_t;


/*! \brief
* Radar RF Phase Shift enable/disable configuration
*/
typedef struct rlRfPhaseShiftCfg
{
    /**
     * @brief  Chirp Start Index, Valid Range 0 -511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp End Index, Valid Range from chirpStartIdx to 511
     */
    rlUInt16_t chirpEndIdx;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  TX0 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX0 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx0PhaseShift;
    /**
     * @brief  TX1 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX1 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx1PhaseShift;
    /**
     * @brief  TX2 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX2 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx2PhaseShift;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  TX1 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX1 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx1PhaseShift;
    /**
     * @brief   TX0 phase shift definition \n
                 [b1:0] reserved (set it to 0b00) \n
                 [b7:2] TX0 phase shift value \n
                 1 LSB = 360/2^6 = 5.625 degrees\n
                 Valid range: 0 to 63 \n
     */
    rlUInt8_t tx0PhaseShift;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  TX2 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX2 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx2PhaseShift;
#endif
}rlRfPhaseShiftCfg_t;

/*! \brief
* Radar RF PA loopback configuration
*/
typedef struct rlRfPALoopbackCfg
{
    /**
     * @brief  value is a 100MHz divider which sets the loopback frequency \n
                For e.g. for a 1 MHz frequency, set this to 100 \n
                For a 2 MHz frequency, set this to 50 \n
                @note : To ensure no leakage of signal power, user has to ensure that \n
                100MHz/LOOPBACK_FREQ is an integer multiple of bin width For e.g. if user \n
                choses 25Msps sampling rate and 2048 samples/chirp, then \n
                LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage \n
     */
    rlUInt16_t paLoopbackFreq;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable PA loopback \n
                1: PA loopback Enable,  0: PA loopback Disable \n
     */
    rlUInt8_t  paLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;

    /**
     * @brief  Enable/Disable PA loopback \n
                1: PA loopback Enable,  0: PA loopback Disable \n
     */
    rlUInt8_t  paLoopbackEn;
#endif
}rlRfPALoopbackCfg_t;

/*! \brief
* Radar RF Phase shift loopback configuration
*/
typedef struct rlRfPSLoopbackCfg
{
    /**
     * @brief  Loop back frequency in kHz, 1 LSB = 1kHz
     */
    rlUInt16_t psLoopbackFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable PA loopback \n
                   1: PS loopback Enable,  0: PS loopback Disable \n
     */
    rlUInt8_t  psLoopbackEn;
    /**
     * @brief  Tx used for loopback \n
     *          [b0] 1: Tx0 is used for loopback \n
     *          [b1] 1: Tx1 is used for loopback \n
     *          [b7:2] : reserved \n
     */
    rlUInt8_t psLoopbackTxId;
    /**
     * @brief  PGA gain value \n
     *           0 : PGA is OFF  \n
     *           1 : -22 dB      \n
     *           2 : -16 dB      \n
     *           3 : -15 dB      \n
     *           4 : -14 dB      \n
     *           5 : -13 dB       \n
     *           6 : -12 dB       \n
     *           7 : -11 dB       \n
     *           8 : -10 dB       \n
     *           9 : -9 dB       \n
     *           10: -8 dB       \n
     *           11: -7 dB       \n
     *           12: -6 dB       \n
     *           13: -5 dB       \n
     *           14: -4 dB       \n
     *           15: -3 dB       \n
     *           16: -2 dB       \n
     *           17: -1 dB       \n
     *           18:  0 dB       \n
     *           19:  1 dB       \n
     *           20:  2 dB       \n
     *           21:  3 dB       \n
     *           22:  4 dB       \n
     *           23:  5 dB       \n
     *           24:  6 dB       \n
     *           25:  7 dB       \n
     *           26:  8 dB       \n
     *           27:  9 dB       \n
     *           255-28:RESERVED \n
     */
    rlUInt8_t pgaGainIndex;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
#else
    /**
     * @brief  Tx used for loopback \n
                [b0] 1: Tx0 is used for loopback \n
                [b1] 1: Tx1 is used for loopback \n
                [b7:2] : reserved \n
     */
    rlUInt8_t psLoopbackTxId;
    /**
     * @brief  Enable/Disable PA loopback \n
                   1: PS loopback Enable,  0: PS loopback Disable \n
     */
    rlUInt8_t  psLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
    /**
     * @brief  PGA gain value \n
     *           0 : PGA is OFF  \n
     *           1 : -22 dB      \n
     *           2 : -16 dB      \n
     *           3 : -15 dB      \n
     *           4 : -14 dB      \n
     *           5 : -13 dB       \n
     *           6 : -12 dB       \n
     *           7 : -11 dB       \n
     *           8 : -10 dB       \n
     *           9 : -9 dB       \n
     *           10: -8 dB       \n
     *           11: -7 dB       \n
     *           12: -6 dB       \n
     *           13: -5 dB       \n
     *           14: -4 dB       \n
     *           15: -3 dB       \n
     *           16: -2 dB       \n
     *           17: -1 dB       \n
     *           18:  0 dB       \n
     *           19:  1 dB       \n
     *           20:  2 dB       \n
     *           21:  3 dB       \n
     *           22:  4 dB       \n
     *           23:  5 dB       \n
     *           24:  6 dB       \n
     *           25:  7 dB       \n
     *           26:  8 dB       \n
     *           27:  9 dB       \n
     *           255-28:RESERVED \n
     */
    rlUInt8_t pgaGainIndex;
#endif
}rlRfPSLoopbackCfg_t;

/*! \brief
* Radar RF IF loopback configuration.
*/
typedef struct rlRfIFLoopbackCfg
{
    /**
     * @brief  IF loopback frequency value \n
     *           0: 180 kHz    \n
     *           1 : 240 kHz   \n
     *           2 : 360 kiHz  \n
     *           3 : 720 kHz   \n
     *           4 : 1 MHz     \n
     *           5 : 2 MHz     \n
     *           6 : 2.5 MHz   \n
     *           7 : 3 MHz     \n
     *           8 : 4.017857 MHz \n
     *           9 : 5 MHz     \n
     *           10 : 6 MHz     \n
     *           11: 8.035714 MHz  \n
     *           12: 9 MHz     \n
     *           13: 10 MHz    \n
     *           65535-14:RESERVED \n
     */
    rlUInt16_t ifLoopbackFreq;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable IF loopback \n
     *          [b7:0] 1: IF loopback Enable,  0: IF loopback Disable \n
     */
    rlUInt8_t ifLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  Enable/Disable IF loopback \n
                [b7:0] 1: IF loopback Enable,  0: IF loopback Disable \n
     */
    rlUInt8_t ifLoopbackEn;
#endif
}rlRfIFLoopbackCfg_t;

/*! \brief
* Array of coefficients for the RF programmable filter
*/
typedef struct rlRfProgFiltCoeff
{
    /**
     * @brief  The array of coefficients for the programmable filter, across all profiles, to
                be stored in the coefficient RAM. Each tap is a 16-bit signed number. The
                exact set of taps to be used for a given profile can be specified through
                rlRfProgFiltConf. \n
                For each profile Maximum of 26 taps can be configured. If multiple profiles
                are used, all the filter taps across profiles are to be provided in one shot. \n
                There is a HW constraint that each profile's filter taps should start at
                an even address. \n

                For e.g If b[i,j] is filter coefficient For Profile i(0,1,2,3) and tap j(0...25),
                if numProfile = 4 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 26 \n
                rlRfProgFiltConf[profileId = 1]. progFiltLen = 26, \n
                rlRfProgFiltConf[profileId = 2]. progFiltLen = 26, \n
                rlRfProgFiltConf[profileId = 3]. progFiltLen = 26, \n

                rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \n
                rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 26 \n
                rlRfProgFiltConf[profileId = 2]. coeffStartIdx = 52 \n
                rlRfProgFiltConf[profileId = 3]. coeffStartIdx = 78 \n
                one need to define this array as following:\n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,25],b[1,0],b[1,1]....
                b[1,25],b[2,0],b[2,1]....b[2,25],b[3,0],b[3,1]....b[3,25]\n

                if numProfile = 1 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \n
                then one need to define this array as following: \n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,9],0,0,0,.....0 \n

                if numProfile = 2 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \n
                rlRfProgFiltConf[profileId = 1]. progFiltLen = 20, \n
                rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 10 \n
                then one need to define this array as following: \n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,9], b[1,0],b[1,1]....b[1,29],0,0,0...0 \n
                @note : All the filter taps across profiles are to be provided in one shot. \n
                        There is a HW constraint that each profile’s filter taps should start \n
                        at four 32-bit word aligned address (i.e., the coefficients corresp- \n
                        onding to any profile should start at array index which is a multiple \n
                        of 8). \n
     */
    rlInt16_t coeffArray[104];
}rlRfProgFiltCoeff_t;

/*! \brief
* Radar RF programmable filter configuration
*/
typedef struct rlRfProgFiltConf
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Profile Index for which this configuration applies.
     */
    rlUInt8_t profileId;
    /**
     * @brief  The index of the first coefficient of the programmable filter taps corresponding
                to this profile in the coefficient RAM programmed using rlRfProgFiltCoeff
                @note 1: This has to be an even number. For odd-length filters, a 0 (zero) tap
                         needs to be appended at the end to make the length even. This is a HW
                         constraint.
                @note 2: The profile’s filter tap start index shall be 8 tap aligned (four 32-bit
                         word aligned address).
     */
    rlUInt8_t coeffStartIdx;
    /**
     * @brief  The length (number of taps) of the filter corresponding  to this profile. Together
               with the previous field, this determines the set of coefficients picked up from the
               coefficient RAM to form the filter taps for this profile.
               @note :  This has to be an even number. For odd-length filters, a 0 (zero) tap
                        needs to be appended at the end to make the length even. This is a HW
                        constraint.
     */
    rlUInt8_t progFiltLen;
    /**
     * @brief  Determines the magnitude of the frequency shift do be done before filtering using
               the real-coefficient programmable filter.
               1 LSB = 0.01*Fs shift, where Fs is the output sampling rate,
               specified as rlProfileCfg_t.digOutSampleRate
               @note 1: Applicable only on the Complex 1X output mode
               @note 2: Consider this example - If the programmable filter's purpose is to 
                        implement a Low Pass Filter to select IF frequencies from 0 to 0.9 x Fs, 
                        a typical way is to apply a -0.45 x Fs frequency shift (program 0.45 Fs in 
                        the API field, as it is unsigned field), and program appropriate low pass 
                        filter coefficients to select frequencies from -0.45 x Fs to +0.45 x Fs. 
                        Note that here Fs refers to the profile's sampling rate (i.e. output 
                        sampling rate), and the programmable filter's sampling rate is 2 x Fs. 
                        Therefore, the programmable filter's output is down-sampled by 2 to form 
                        the device's ADC data output. Further note, that the IF spectrum remains 
                        "shifted" by this amount (it is not "shifted back") and this known 
                        frequency shift can be accounted for in further DSP post processing.
     */
    rlUInt8_t progFiltFreqShift;
#else
    /**
     * @brief  The index of the first coefficient of the programmable filter taps corresponding
                to this profile in the coefficient RAM programmed using rlRfProgFiltCoeff
                @note 1: This has to be an even number. For odd-length filters, a 0 (zero) tap
                         needs to be appended at the end to make the length even. This is a HW
                         constraint.
                @note 2: The profile’s filter tap start index shall be 8 tap aligned (four 32-bit
                         word aligned address).
     */
    rlUInt8_t coeffStartIdx;
    /**
     * @brief  Profile Index for which this configuration applies.
     */
    rlUInt8_t profileId;
    /**
     * @brief  Determines the magnitude of the frequency shift do be done before filtering using
               the real-coefficient programmable filter.
               1 LSB = 0.01*Fs shift, where Fs is the output sampling rate,
               specified as rlProfileCfg_t.digOutSampleRate
               @note 1: Applicable only on the Complex 1X output mode
               @note 2: Consider this example - If the programmable filter's purpose is to 
                        implement a Low Pass Filter to select IF frequencies from 0 to 0.9 x Fs, 
                        a typical way is to apply a -0.45 x Fs frequency shift (program 0.45 Fs in 
                        the API field, as it is unsigned field), and program appropriate low pass 
                        filter coefficients to select frequencies from -0.45 x Fs to +0.45 x Fs. 
                        Note that here Fs refers to the profile's sampling rate (i.e. output 
                        sampling rate), and the programmable filter's sampling rate is 2 x Fs. 
                        Therefore, the programmable filter's output is down-sampled by 2 to form 
                        the device's ADC data output. Further note, that the IF spectrum remains 
                        "shifted" by this amount (it is not "shifted back") and this known 
                        frequency shift can be accounted for in further DSP post processing.
     */
    rlUInt8_t progFiltFreqShift;
    /**
     * @brief  The length (number of taps) of the filter corresponding  to this profile. Together
               with the previous field, this determines the set of coefficients picked up from the
               coefficient RAM to form the filter taps for this profile.
               @note :  This has to be an even number. For odd-length filters, a 0 (zero) tap
                        needs to be appended at the end to make the length even. This is a HW
                        constraint.
     */
    rlUInt8_t progFiltLen;
#endif
}rlRfProgFiltConf_t;

/*! \brief
* Radar RF Miscconfiguration
*/
typedef struct rlRfMiscConf
{
    /**
     * @brief  b0 PERCHIRP_PHASESHIFTER_EN \n
     *          0 Per chirp phase shifter is disabled \n
     *          1 Per chirp phase shifter is enabled \n
     *          This control is applicable only in devices which support phase shifter. \n
     *          For other devices, this is a RESERVED bit and should be set to 0.
     *         b1 ADVANCE_CHIRP_CONFIG_EN \n
     *          0 Advance chirp config mode is disabled \n
     *          1 Advance chirp config mode is enabled \n
     *          This feature enables advanced mode of configuring chirps to achieve very flexible
     *          waveform generation. \n
     *         b2 ADVANCE_CHIRP_ERROR_CHK_DIS \n
     *          0 Advance chirp parameters error check enabled in frame config API \n
     *          1 Advance chirp parameters error check disabled in frame config API \n
     *          By default Error check is enabled for each and every parameters of advance chirp 
     *          based on waveform pattern in legacy and advance frame config API, this would take 
     *          around 1.8ms to process frame config for 128 chirps. 
     *          This option enables the user to disable the error check in functional mode and 
     *          error check can be done only during development phase. If this error check takes 
     *          more than 50ms due to large number of chirps then it is recommended to disable 
     *          RadarSS WDT while executing frame config API. \n
     *         b3 CAL_MON_TIME_UNIT_ERROR_CHK_DIS \n
     *          0 Calibration and Monitor time error check is enabled in 
     *            AWR_FRAMESTARTSTOP_CONF_SB API \n
     *          1 Calibration and Monitor time error check is disabled in 
     *            AWR_FRAMESTARTSTOP_CONF_SB API \n
     *          By default Calibration and Monitor time Error check is enabled and performed in 
     *          frame start API, this error check generates AWR_CAL_MON_TIMING_FAIL_REPORT_AE_SB 
     *          AE if total available idle time in a CALIB_MON_TIME_UNIT configured in 
     *          AWR_CALIB_MON_TIME_UNIT_CONF_SB API is not sufficient to run all enabled 
     *          calibrations and Monitors. \n
     *          This option enables the user to disable the error check in advance continuous 
     *          framing mode where idle time is split across multiple bursts in a 
     *          CALIB_MON_TIME_UNIT window. The calibration and monitors need idle time only to 
     *          run critical chirps for measurements, the setup and post processing can be done 
     *          in background while functional frames are running. \n
     *          Refer \ref AnalogMonitoringDuration and \ref runTimeCalibration for more info. \n
     *          Default value: 0 \n
     *         b31:4 RESERVED \n
     */
    rlUInt32_t miscCtl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved;
}rlRfMiscConf_t;

/*! \brief
* Radar RF Calibration monitoring time unit configuration
*/
typedef struct rlRfCalMonTimeUntConf
{
    /**
     * @brief  Defines the basic time unit, in terms of which calibration and/or monitoring \n
                periodicities are to be defined. \n
                If any monitoring functions are desired and enabled, the monitoring infrastructure
                automatically inherits this time unit as the period over which the various monitors
                are cyclically executed; so this should be set to the desired FTTI. \n
                For calibrations, a separate rlRunTimeCalibConf.calibPeriodicity can be specified,
                as a multiple of this time unit, in rlRfRunTimeCalibConfig. \n
                1 LSB = Duration of one frame. \n
        @note : Even though calibrations many not be desired every time unit, every time unit shall
                be made long enough to include active chirping time, time required for all enabled
                calibrations and monitoring functions.
                Default value in device: 100 \n
                Valid range : 40ms to 250ms (Derive actual count value from programmed frame \n
                period) \n
        @note : In cascade mode this value shall be configured based on monitoring time required 
                to monitor all cascade devices. \n
                For example in MONITORING_MODE 0 (Auto mode) typical CALIB_MON_TIME_UNIT value is 
                4x (4 chip cascade system) compared to single chip monitor duration. Host shall 
                program cascade system CALIB_MON_TIME_UNIT value in all devices (4x in Auto mode), 
                the RadarSS schedules the monitors in round robin fashion using 
                NUM_OF_CASCADED_DEV and DEVICE_ID settings. \n
                In MONITORING_MODE 1 (API based trigger), this value shall be configured based on 
                monitoring time required to monitor all cascade devices using API based trigger. \n
     */
    rlUInt16_t calibMonTimeUnit;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  The number of cascaded devices in system. \n
               This configuration by default set to value 1 in single chip mode. \n
               In Cascade mode, this configuration can be set to Max num of devices in the cascade 
               system and this needs to be set based on MONITORING_MODE setting. This control 
               helps the device to schedule autonomous monitors in round robin fashion to avoid 
               inter device interference. \n
               If MONITORING_MODE is 0 (Autonomous Mode - Device automatically controls the 
               sequence of monitoring triggers), then recommended to set this configuration to 
               Max num of devices (Example value 4 in 4-chip cascade system). \n
               If MONITORING_MODE is 1 (API based trigger Mode - Host controls the sequence of 
               monitoring triggers), then recommended to set this configuration to value 1 
               irrespective of num of cascade devices. \n
               Default value: 1 \n
     */
    rlUInt8_t  numOfCascadeDev;
    /**
     * @brief  Device Index value for each devices in cascade system. \n
               This configuration by default set to value 0 in single chip mode. \n
               In Cascade mode, this configuration can be set to value 0, 1, 2, 3 .. depending on 
               Max num of devices in the cascade system and this needs to be set based on 
               MONITORING_MODE setting. This control helps the device to schedule autonomous 
               monitors in round robin fashion to avoid inter device interference. \n
               If MONITORING_MODE is 0 (Autonomous Mode - Device automatically controls the 
               sequence of monitoring triggers), then recommended to set this configuration to 
               0 (master), 1 (slave), 2(slave), 3(slave) in 4-chip cascade system. \n
               If MONITORING_MODE is 1 (API based trigger Mode - Host controls the sequence of 
               monitoring triggers), then recommended to set this configuration to value 0 in all 
               cascade devices. \n
               Default value = 0 \n
     */
    rlUInt8_t  devId;
    /**
     * @brief  Monitoring mode. \n
               Mostly applicable for cascade devices (recommended) to control execution of 
               monitoring types, refer \ref rlMonTypeTrigCfg_t for more details. \n
               0: Autonomous monitoring trigger (default in single chip mode) \n
               1: API based monitoring trigger (recommended in cascade mode) \n
               @note : This feature is supported only on AWR2243/xWR6243 device.
               @note : Disable WDT if API based monitoring trigger is enabled.
     */
    rlUInt8_t  monitoringMode;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved;
#else
    /**
     * @brief  Device Index value for each devices in cascade system. \n
               This configuration by default set to value 0 in single chip mode. \n
               In Cascade mode, this configuration can be set to value 0, 1, 2, 3 .. depending on 
               Max num of devices in the cascade system and this needs to be set based on 
               MONITORING_MODE setting. This control helps the device to schedule autonomous 
               monitors in round robin fashion to avoid inter device interference. \n
               If MONITORING_MODE is 0 (Autonomous Mode - Device automatically controls the 
               sequence of monitoring triggers), then recommended to set this configuration to 
               0 (master), 1 (slave), 2(slave), 3(slave) in 4-chip cascade system. \n
               If MONITORING_MODE is 1 (API based trigger Mode - Host controls the sequence of 
               monitoring triggers), then recommended to set this configuration to value 0 in all 
               cascade devices. \n
               Default value = 0 \n
     */
    rlUInt8_t  devId;
    /**
     * @brief  The number of cascaded devices in system. \n
               This configuration by default set to value 1 in single chip mode. \n
               In Cascade mode, this configuration can be set to Max num of devices in the cascade 
               system and this needs to be set based on MONITORING_MODE setting. This control 
               helps the device to schedule autonomous monitors in round robin fashion to avoid 
               inter device interference. \n
               If MONITORING_MODE is 0 (Autonomous Mode - Device automatically controls the 
               sequence of monitoring triggers), then recommended to set this configuration to 
               Max num of devices (Example value 4 in 4-chip cascade system). \n
               If MONITORING_MODE is 1 (API based trigger Mode - Host controls the sequence of 
               monitoring triggers), then recommended to set this configuration to value 1 
               irrespective of num of cascade devices. \n
               Default value: 1 \n
     */
    rlUInt8_t  numOfCascadeDev;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved;
    /**
     * @brief  Monitoring mode. \n
               Mostly applicable for cascade devices (recommended) to control execution of 
               monitoring types, refer \ref rlMonTypeTrigCfg_t for more details. \n
               0: Autonomous monitoring trigger (default in single chip mode) \n
               1: API based monitoring trigger (recommended in cascade mode) \n
               @note : This feature is supported only on AWR2243/xWR6243 device.
               @note : Disable WDT if API based monitoring trigger is enabled.
     */
    rlUInt8_t  monitoringMode;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
}rlRfCalMonTimeUntConf_t;

/*! \brief
* Radar RF Calibration monitoring Frequency Limit configuration
*/
typedef struct rlRfCalMonFreqLimitConf
{
    /**
     * @brief  The sensor's lower frequency limit for calibrations and monitoring is encoded \n
     *          in 2 bytes (16 bit unsigned number) \n
     *          1 LSB = 100 MHz \n
     *          For 77GHz devices(76GHz to 81GHz) \n
     *              Valid range: 760 to 810
     *              Default value : 760 (If API is not issued)
     *          For 60GHz devices(56GHz/57GHz to 64GHz) \n
     *              Valid range: 560/570 to 640
     *              Default value : 560/570 (If API is not issued)
     *          @note : Refer to device datasheet for supported frequency ranges \n
     */
    rlUInt16_t freqLimitLow;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring is encoded \n
     *          in 2 bytes (16 bit unsigned number) \n
     *          1 LSB = 100 MHz \n
     *          For 77GHz devices(76GHz to 81GHz) \n
     *              Valid range: 760 to 810
     *              Default value : 810 (If API is not issued)
     *          For 60GHz devices(57.2GHz to 64GHz) \n
     *              Valid range: 572 to 640
     *              Default value : 640 (If API is not issued)
     *          @note : FREQ_LIMIT_HIGH should be strictly greater than FREQ_LIMIT_LOW \n
     */
    rlUInt16_t freqLimitHigh;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
}rlRfCalMonFreqLimitConf_t;

/*! \brief
* Radar RF Init Calibration configuration
*/
typedef struct rlRfInitCalConf
{
    /**
     * @brief  Allowed values = 0x000 or 0xFFF. Normally, upon receiving RF INIT message, the 
     *         radarSS performs all relevant initial calibrations. Host can disable each boot 
     *         calibration by setting the corresponding calibration bit in this field to 0x0. 
     *         If disabled, the host needs to inject calibration data using 
     *         AWR_CAL_DATA_RESTORE_SB API..Each of these calibrations can be selectively
     *         disabled by issuing this message before RF INIT message. \n
     *
     *         Bit Calibration \n
     *         0   [Reserved] \n
     *         1   [Reserved] \n
     *         2   [Reserved] \n
     *         3   [Reserved] \n
     *         4   Enable LODIST calibration \n
     *         5   Enable RX ADC DC offset calibration \n
     *         6   Enable HPF cutoff calibration \n
     *         7   Enable LPF cutoff calibration \n
     *         8   Enable Peak detector calibration \n
     *         9   Enable TX Power calibration \n
     *         10  Enable RX gain calibration \n
     *         11  Enable TX phase calibration (Device dependent feature, please refer data
     *             sheet) \n
     *         12  Enable RX IQMM calibration \n
     *         31:13   [Reserved] \n
     *         @note 1: If calibrations are disabled, then it is mandatory to restore the same. \n
     */
    rlUInt32_t calibEnMask;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved1;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved3;
}rlRfInitCalConf_t;

/*! \brief
* Radar RF Run time calibration configuration
*/
typedef struct rlRunTimeCalibConf
{
    /**
     * @brief   Upon receiving this trigger message, one time calibration of various RF/analog \n
     *          aspects are triggered if the corresponding bits in this field are set to 1. The \n
     *          response is in the form of an asynchronous event sent to the host. The \n
     *          calibrations, if enabled, are performed after the completion of any ongoing \n
     *          calibration cycle, and the calibration results take event from the frame that \n
     *          begins after the asynchronous event response is sent from the BSS. \n
     *          APLL and SYNTH calibrations are done always internally irrespective of bits are \n
     *          enabled or not, the time required for these calibrations must be allocated. \n
     *          Bit: Calibration \n
     *            0:[Reserved]  \n
     *            1:[Reserved]  \n
     *            2:[Reserved]  \n
     *            3:[Reserved]  \n
     *            4: Enable LODIST calibration  \n
     *            5: [Reserved]  \n
     *            6: [Reserved]  \n
     *            7: [Reserved]  \n
     *            8: Enable PD_CALIBRATION_EN \n
     *            9: Enable TX Power calibration \n
     *            10:Enable RX gain calibration  \n
     *            11:[Reserved]  \n
     *            12:[Reserved]  \n
     *            31:13:[Reserved] \n
     */
    rlUInt32_t oneTimeCalibEnMask;
    /**
     * @brief  Automatic periodic triggering of calibrations of various RF/analog aspects. \n
               It has same bit definition as above \n
               @note : In cascade mode it is recommended to disable (set value 0 in this field) 
                       automated periodic calibration for phase synchronization.
     */
    rlUInt32_t periodicCalibEnMask;
    /**
     * @brief  This field is applicable only for those calibrations which are enabled to be \n
     *         done periodically in the periodicCalibEnMask field. This field indicates the \n
     *         desired periodicity of calibrations. If this field is set to N, the results of \n
     *         the first calibration (based on oneTimeCalibEnMask) are applicable for the first \n
     *         N calibMonTimeUnits. The results of the next calibration are applicable for \n
     *         the next N calibMonTimeUnits, and so on.
     *         Recommendation: Set calibPeriodicity such that frequency of calibrations is \n
     *         greater than or equal to 1 second. 1 LSB = 1 calibMonTimeUnit, as specified \n
     *         in rlRfSetCalMonTimeUnitConfig. If the user does not wish to receive \n
     *         calibration reports when periodic calibrations are not enabled, then the user \n
     *         should set calibPeriodicity to 0.
     *         Default value: 0
     *         Valid Range: 0 (Disable), 4 to 100 (value 1 is not a valid value, this will cause \n
     *         internal APLL and SYNTH calibrations to stop)
     */
    rlUInt32_t calibPeriodicity;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Calibration Report Enable Configuration \n
                [b0]  Enable Calibration Reports Bitmap \n
                       0 -  Disable Calibration Reports \n
                       1 -  Enable Calibration Reports \n
                [b7:1] Reserved \n
                @note 1: If calibration reports are enabled, the reports will be sent every 1
                        second whenever internal calibrations (APLL and SYNTH) are triggered \n
                        and at every CALIBRATION PERIODICITY when the user enabled calibrations
                        are triggered. \n
                @note 2: If user has not enabled any one time calibrations, but if calibration
                         report is enabled, then after issuing this API, the firmware will \n
                         attempt to run the APLL and SYNTH calibrations and the calibration report
                         will be immediately sent out. \n
     */
    rlUInt8_t  reportEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
    * @brief  TX Power Calibration Mode
              [b0]  Enable Calibration Reports Bitmap \n
                    0 - Update TX gain setting from LUT and do a closed loop calibration \n
                        (OLPC + CLPC) \n
                    1 - Update TX gain settings from LUT only (OLPC only) \n
                        OLPC: Open Loop Power Control. In this mode the TX stage codes are set \n
                        based on a coarse measurement and a LUT generated for every temperature \n
                        and the stage codes are picked from the LUT CLPC: Closed Loop Power \n
                        Control. In this mode the TX stage codes are picked from the coarse LUT \n
                        as generated in OLPC step. Later the TX power is measured and the TX \n
                        stage codes are corrected to achieve the desired TX power accuracy. \n
                        Default value: 0 \n
              [b7:1] Reserved \n
    */
    rlUInt8_t txPowerCalMode;
    /**
    * @brief  Calibration Temperature Index Override Enable \n
              Enables the Host to override the use of device’s internal temperature readings 
              for choosing front end calibration settings (e.g. bias current, Rx Gain and 
              Tx Gain LUT). \n
              [b0]  TX_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n
              [b1]  RX_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n
              [b2]  LODIST_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n                    
              [b7:3] Reserved \n
              Default value: 0 (Override disable, use device temperature) \n
    @note : This feature is supported only on AWR2243/xWR6243 device.
    @note : If any of the override bits are enabled, AWR_RF_INIT_SB should not be invoked again.
    */
    rlUInt8_t CalTempIdxOverrideEn;
    /**
    * @brief  Override temperature index is used to calibrate Tx front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxTx;
    /**
    * @brief  Override temperature index is used to calibrate Rx front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxRx;
    /**
    * @brief  Override temperature index is used to calibrate LO distribution of front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxLodist;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Calibration Report Enable Configuration \n
                   [b0]  Enable Calibration Reports Bitmap \n
                         0 - Disable Calibration Reports \n
                         1 - Enable Calibration Reports \n
                   [b7:1] Reserved \n
     */
    rlUInt8_t  reportEn;
    /**
    * @brief  Calibration Temperature Index Override Enable \n
              Enables the Host to override the use of device’s internal temperature readings 
              for choosing front end calibration settings (e.g. bias current, Rx Gain and 
              Tx Gain LUT). \n
              [b0]  TX_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n
              [b1]  RX_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n
              [b2]  LODIST_TEMP_INDEX_OVERRIDE_EN \n
                    0 - Override disable \n
                    1 - Override enable \n                    
              [b7:3] Reserved \n
              Default value: 0 (Override disable, use device temperature) \n
    @note : This feature is supported only on AWR2243/xWR6243 device.
    @note : If any of the override bits are enabled, AWR_RF_INIT_SB should not be invoked again.
    */
    rlUInt8_t CalTempIdxOverrideEn;
    /**
     * @brief  TX Power Calibration Mode
             [b0]  Enable Calibration Reports Bitmap \n
                   0 - Update TX gain setting from LUT and do a closed loop calibration \n
                       (OLPC + CLPC) \n
                   1 - Update TX gain settings from LUT only (OLPC only) \n
                       OLPC: Open Loop Power Control. In this mode the TX stage codes are set \n
                       based on a coarse measurement and a LUT generated for every temperature \n
                       and the stage codes are picked from the LUT CLPC: Closed Loop Power \n
                       Control. In this mode the TX stage codes are picked from the coarse LUT \n
                       as generated in OLPC step. Later the TX power is measured and the TX \n
                       stage codes are corrected to achieve the desired TX power accuracy. \n
                       Default value: 0 \n
             [b7:1] Reserved \n

     */
     rlUInt8_t txPowerCalMode;
    /**
    * @brief  Override temperature index is used to calibrate Rx front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxRx;
    /**
    * @brief  Override temperature index is used to calibrate Tx front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxTx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
    /**
    * @brief  Override temperature index is used to calibrate LO distribution of front end \n
    *      Idx val             Definition
    *         0:  Index for temperature < -30 deg C \n
    *         1:  Index for to temperature [-30, -20) deg C \n
    *         2:  Index for to temperature [-20, -10) deg C \n
    *         3:  Index for to temperature [-10, 0) deg C \n
    *         4:  Index for to temperature [0, 10) deg C \n
    *         5:  Index for to temperature [10, 20) deg C \n
    *         6:  Index for to temperature [20, 30) deg C \n
    *         7:  Index for to temperature [30, 40) deg C \n
    *         8:  Index for to temperature [40, 50) deg C \n
    *         9:  Index for to temperature [50, 60) deg C \n
    *         10: Index for to temperature [60, 70) deg C \n
    *         11: Index for to temperature [70, 80) deg C \n
    *         12: Index for to temperature [80, 90) deg C \n
    *         13: Index for to temperature [90, 100) deg C \n
    *         14: Index for to temperature [100, 110) deg C \n
    *         15: Index for to temperature [110, 120) deg C \n
    *         16: Index for to temperature [120, 130) deg C \n
    *         17: Index for to temperature [130, 140) deg C \n
    *         18: Index for to temperature >= 140 deg C \n
    */
    rlUInt8_t CalTempIdxLodist;
#endif
}rlRunTimeCalibConf_t;

/*! \brief
* RX gain temperature LUT read
*/
typedef struct rlRxGainTempLutReadReq
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
} rlRxGainTempLutReadReq_t;

/*! \brief
* TX gain temperature LUT read
*/
typedef struct rlTxGainTempLutReadReq
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
} rlTxGainTempLutReadReq_t;

/*! \brief
* RX gain temperature LUT inject
*/
typedef struct rlRxGainTempLutData
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Byte0: RX gain code for temperature < -30 deg C \n
     *         Byte1: RX gain code for temperature [-30, -20) deg C \n
     *         Byte2: RX gain code for temperature [-20, -10) deg C \n
     *         Byte3: RX gain code for temperature [-10, 0) deg C \n
     *         Byte4: RX gain code for temperature [0, 10) deg C \n
     *         Byte5: RX gain code for temperature [10, 20) deg C \n
     *         Byte6: RX gain code for temperature [20, 30) deg C \n
     *         Byte7: RX gain code for temperature [30, 40) deg C \n
     *         Byte8: RX gain code for temperature [40, 50) deg C \n
     *         Byte9: RX gain code for temperature [50, 60) deg C \n
     *         Byte10: RX gain code for temperature [60, 70) deg C \n
     *         Byte11: RX gain code for temperature [70, 80) deg C \n
     *         Byte12: RX gain code for temperature [80, 90) deg C \n
     *         Byte13: RX gain code for temperature [90, 100) deg C \n
     *         Byte14: RX gain code for temperature [100, 110) deg C \n
     *         Byte15: RX gain code for temperature [110, 120) deg C \n
     *         Byte16: RX gain code for temperature [120, 130) deg C \n
     *         Byte17: RX gain code for temperature [130, 140) deg C \n
     *         Byte18: RX gain code for temperature >= 140 deg C \n
     *         Byte19: RESERVED. Set it to 0x00 \n
     *         Each byte is encoded as follows \n
     *         Bits Definition\n
     *             [4:0]   IF_GAIN_CODE \n
     *                     IF gain is IF_GAIN_CODE * 2 - 6 dB \n
     *                     Valid Range : \n
     *                     Temperature < 10degC: The max IFA gain code supported is 12 (24dB). \n
     *                     Temperature >= 10degC: The max IFA gain code supported is 15 (30dB). \n
     *                     1 LSB = 2 dB \n
     *             [7:5]   RF_GAIN_CODE \n
     *                     AWR2243 device: \n
     *                      Value RF Gain \n
     *                       0    Maximum RF gain \n
     *                       1    Maximum RF gain .. 2.5 dB \n
     *                       2    Maximum RF gain .. 5 dB \n
     *                     xWR6243 device: \n
     *                      Value RF Gain \n
     *                       0    Maximum RF gain \n
     *                       1    Maximum RF gain .. 3.5 dB \n
     *                       2    Maximum RF gain .. 6 dB \n
     */
    rlUInt8_t  rxGainTempLut[RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Gain code for Rx0/1/2/3 \n
     *          Byte0: RX gain code for temperature [-30, -20) deg C \n
     *          Byte1: RX gain code for temperature < -30 deg C \n
     *          Byte2: RX gain code for temperature [-10, 0) deg C \n
     *          Byte3: RX gain code for temperature [-20, -10) deg C \n
     *          Byte4: RX gain code for temperature [10, 20) deg C \n
     *          Byte5: RX gain code for temperature [0, 10) deg C \n
     *          Byte6: RX gain code for temperature [30, 40) deg C \n
     *          Byte7: RX gain code for temperature [20, 30) deg C \n
     *          Byte8: RX gain code for temperature [50, 60) deg C \n
     *          Byte9: RX gain code for temperature [40, 50) deg C \n
     *          Byte10: RX gain code for temperature [70, 80) deg C \n
     *          Byte11: RX gain code for temperature [60, 70) deg C \n
     *          Byte12: RX gain code for temperature [90, 100) deg C \n
     *          Byte13: RX gain code for temperature [80, 90) deg C \n
     *          Byte14: RX gain code for temperature [110, 120) deg C \n
     *          Byte15: RX gain code for temperature [100, 110) deg C \n
     *          Byte16: RX gain code for temperature [130, 140) deg C \n
     *          Byte17: RX gain code for temperature [120, 130) deg C \n
     *          Byte18: RESERVED. Set it to 0x00 \n
     *          Byte19: RX gain code for temperature >= 140 deg C \n
     *          Each byte is encoded as follows \n
     *          Bits Definition \n
     *             [4:0]   IF_GAIN_CODE \n
     *                     IF gain is IF_GAIN_CODE * 2 - 6 dB \n
     *                     Valid Range : \n
     *                     Temperature < 10degC: The max IFA gain code supported is 12 (24dB). \n
     *                     Temperature >= 10degC: The max IFA gain code supported is 15 (30dB). \n
     *                     1 LSB = 2 dB \n
     *             [7:5]   RF_GAIN_CODE \n
     *                     AWR2243 device: \n
     *                      Value RF Gain \n
     *                       0    Maximum RF gain \n
     *                       1    Maximum RF gain .. 2.5 dB \n
     *                       2    Maximum RF gain .. 5 dB \n
     *                     xWR6243 device: \n
     *                      Value RF Gain \n
     *                       0    Maximum RF gain \n
     *                       1    Maximum RF gain .. 3.5 dB \n
     *                       2    Maximum RF gain .. 6 dB \n
     */
    rlUInt8_t  rxGainTempLut[RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved1;
} rlRxGainTempLutData_t;

/*! \brief
* TX gain temperature LUT inject
*/
typedef struct rlTxGainTempLutData
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Gain code for Tx0/1/2 \n
     *          Byte0: TX gain code for temperature < -30 deg C \n
     *          Byte1: TX gain code for temperature [-30, -20) deg C \n
     *          Byte2: TX gain code for temperature [-20, -10) deg C \n
     *          Byte3: TX gain code for temperature [-10, 0) deg C \n
     *          Byte4: TX gain code for temperature [0, 10) deg C \n
     *          Byte5: TX gain code for temperature [10, 20) deg C \n
     *          Byte6: TX gain code for temperature [20, 30) deg C \n
     *          Byte7: TX gain code for temperature [30, 40) deg C \n
     *          Byte8: TX gain code for temperature [40, 50) deg C \n
     *          Byte9: TX gain code for temperature [50, 60) deg C \n
     *          Byte10: TX gain code for temperature [60, 70) deg C \n
     *          Byte11: TX gain code for temperature [70, 80) deg C \n
     *          Byte12: TX gain code for temperature [80, 90) deg C \n
     *          Byte13: TX gain code for temperature [90, 100) deg C \n
     *          Byte14: TX gain code for temperature [100, 110) deg C \n
     *          Byte15: TX gain code for temperature [110, 120) deg C \n
     *          Byte16: TX gain code for temperature [120, 130) deg C \n
     *          Byte17: TX gain code for temperature [130, 140) deg C \n
     *          Byte18: TX gain code for temperature >= 140 deg C \n
     *          Byte19: RESERVED. Set it to 0x00 \n
     *         Each byte is encoded as follows \n
     *         Bits Definition \n
     *         [7:0]  STG_CODE \n
     *                Higher values for higher gain \n
     */
    rlUInt8_t  txGainTempLut[RL_TX_CNT][RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief    This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Gain code for Tx0/1/2 \n
     *          Byte0: TX gain code for temperature [-30, -20) deg C \n
     *          Byte1: TX gain code for temperature < -30 deg C \n
     *          Byte2: TX gain code for temperature [-10, 0) deg C \n
     *          Byte3: TX gain code for temperature [-20, -10) deg C \n
     *          Byte4: TX gain code for temperature [10, 20) deg C \n
     *          Byte5: TX gain code for temperature [0, 10) deg C \n
     *          Byte6: TX gain code for temperature [30, 40) deg C \n
     *          Byte7: TX gain code for temperature [20, 30) deg C \n
     *          Byte8: TX gain code for temperature [50, 60) deg C \n
     *          Byte9: TX gain code for temperature [40, 50) deg C \n
     *          Byte10: TX gain code for temperature [70, 80) deg C \n
     *          Byte11: TX gain code for temperature [60, 70) deg C \n
     *          Byte12: TX gain code for temperature [90, 100) deg C \n
     *          Byte13: TX gain code for temperature [80, 90) deg C \n
     *          Byte14: TX gain code for temperature [110, 120) deg C \n
     *          Byte15: TX gain code for temperature [100, 110) deg C \n
     *          Byte16: TX gain code for temperature [130, 140) deg C \n
     *          Byte17: TX gain code for temperature [120, 130) deg C \n
     *          Byte18: RESERVED. Set it to 0x00 \n
     *          Byte19: TX gain code for temperature >= 140 deg C \n
     *         Each byte is encoded as follows \n
     *         Bits Definition \n
     *         [7:0]  STG_CODE \n
     *                Higher values for higher gain \n
     */
    rlUInt8_t  txGainTempLut[RL_TX_CNT][RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved1;
} rlTxGainTempLutData_t;

/*! \brief
* Tx freq and power limit configuration
*/
typedef struct rlRfTxFreqPwrLimitMonConf
{
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX0 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx0;
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX1 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx1;
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX2 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx2;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX0 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               @note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx0;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX1 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               @note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx1;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX2 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               @note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx2;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  TX0 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx0PwrBackOff;
    /**
     * @brief  TX1 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
       */
    rlUInt8_t tx1PwrBackOff;
    /**
     * @brief  TX2 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx2PwrBackOff;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  TX1 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx1PwrBackOff;
    /**
     * @brief  TX0 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx0PwrBackOff;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  TX2 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx2PwrBackOff;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved3;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved4;
}rlRfTxFreqPwrLimitMonConf_t;

/*! \brief
* Loopback burst set configuration
*/
typedef struct rlLoopbackBurst
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief Loopback selection  \n
     *          Value Definition  \n
     *          0     No loopback \n
     *          1     IF loopback (loopback of an IF test signal into the RX IF stages) \n
     *          2     PS loopback (loopback of an RF test signal from TX phase shifter outputs 
     *                             to RX LNA input) \n
     *          3     PA loopback (loopback of an RF test signal from TX PA outputs to RX LNA 
     *                             input with On-off-keying modulation in the path) \n
     *          4     Rx FE disabled (RX RF i.e. Mixer and LNA are disabled and no loopback is 
     *                                engaged) \n
     *          Others RESERVED   \n
     */
    rlUInt8_t  loopbackSel;
    /**
     * @brief Base profile used for loopback chirps to configure the RF/analog/digital front end 
     *        sections. But the configurations of some sections may get overwritten by the 
     *        parameters configured below. \n
     *        Valid values 0 to 3 \n
     */
    rlUInt8_t  baseProfileIndx;
    /**
     * @brief Indicates the index of the burst in the loopback sub-frame for which \n
     *          this configuration applies \n
     *          Valid values 0 to 15       \n
     */
    rlUInt8_t  burstIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief Base profile used for loopback chirps to configure the RF/analog/digital front end 
     *        sections. But the configurations of some sections may get overwritten by the 
     *        parameters configured below. \n
     *        Valid values 0 to 3 \n
     */
    rlUInt8_t  baseProfileIndx;
    /**
     * @brief Loopback selection  \n
     *          Value Definition  \n
     *          0     No loopback \n
     *          1     IF loopback (loopback of an IF test signal into the RX IF stages) \n
     *          2     PS loopback (loopback of an RF test signal from TX phase shifter outputs 
     *                             to RX LNA input) \n
     *          3     PA loopback (loopback of an RF test signal from TX PA outputs to RX LNA 
     *                             input with On-off-keying modulation in the path) \n
     *          4     Rx FE disabled (RX RF i.e. Mixer and LNA are disabled and no loopback is 
     *                                engaged) \n
     *          Others RESERVED   \n
     */
    rlUInt8_t  loopbackSel;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief Indicates the index of the burst in the loopback sub-frame for which \n
     *          this configuration applies \n
     *          Valid values 0 to 15       \n
     */
    rlUInt8_t  burstIndx;
#endif
    /**
     * @brief  Start frequency for loopback \n
     *           For 77GHz devices (76 GHz to 81 GHz): \n
     *               1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \n
     *               Valid range: 0x5471C71B to 0x5A000000 \n
     *           For 60GHz devices (57 GHz to 64 GHz): \n
     *               1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \n
     *               Valid range: Only even numbers from 0x5471C71C to 0x5ED097B4 \n
     */
    rlUInt32_t freqConst;
    /**
     * @brief  Ramp slope for loopback burst (16 bit signed number) \n
     *           For 77GHz devices (76 GHz to 81 GHz): \n
     *               1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \n
     *               Valid range: -2072 to 2072 (Max 100MHz/uS) \n
     *           For 60GHz devices (57 GHz to 64 GHz): \n
     *               1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS \n
     *               Valid range: Only even numbers between -6905 to 6905 (Max 250 MHz/uS) \n
     */
    rlInt16_t  slopeConst;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2\n
                   b7:0 TX0 output power back off \n
                   b15:8 TX1 output power back off \n
                   b23:16 TX2 output power back off \n
                   b31:24 Reserved \n
               @note : This setting is applicable only in PA loop-back mode. \n
     */
    rlUInt32_t txBackoff;
    /**
     * @brief
                b5:0  This field defines RX gain for each channel. \n
                      1 LSB = 1 dB \n
                      Valid values: \n
                      AWR2243 : All even values from 32 to 52 \n
                      xWR6x43 : All even values from 30 to 48 \n
                b7:6  Code for RF gain target \n
                      The RF gain target for AWR2243/xWR6x43 device:
                      Value      RF gain target
                      00         30 dB \n
                      01         33 dB \n
                      10         36 dB (Recommended) \n
                      11         RESERVED \n
                b15:8 RESERVED \n
                @note : This setting is applicable only in PA and PS loop-back modes. \n
     */
    rlUInt16_t rxGain;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Tx enable selection bit mask \n
     *          b0 Enable TX0  \n
     *           0 Tx0 Disable \n
     *           1 Tx0 Enable  \n
     *          b1 Enable TX1  \n
     *           0 Tx1 Disable \n
     *           1 Tx1 Enable  \n
     *          b2 Enable TX2 (PS LB not supported for TX2) \n
     *           0 Tx2 Disable \n
     *           1 Tx2 Enable  \n
     * @note : This setting is applicable in all loop-back modes \n
     */
    rlUInt8_t  txEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
    /**
     * @brief  Tx enable selection bit mask \n
     *          b0 Enable TX0  \n
     *           0 Tx0 Disable \n
     *           1 Tx0 Enable  \n
     *          b1 Enable TX1  \n
     *           0 Tx1 Disable \n
     *           1 Tx1 Enable  \n
     *          b2 Enable TX2 (PS LB not supported for TX2) \n
     *           0 Tx2 Disable \n
     *           1 Tx2 Enable  \n
     * @note : This setting is applicable in all loop-back modes \n
     */
    rlUInt8_t  txEn;
#endif
    /**
     * @brief   Bit Definition              \n
     *          b0  RESERVED                \n
     *          b1  CONST_BPM_VAL_TX0_ON    \n
     *               Value of Binary Phase Shift value for TX0, during chirp      \n
     *          b2  RESERVED                \n
     *          b3  CONST_BPM_VAL_TX1_ON    \n
     *               Value of Binary Phase Shift value for TX1, during chirp      \n
     *          b4  RESERVED                \n
     *          b5  CONST_BPM_VAL_TX2_ON    \n
     *               Value of Binary Phase Shift value for TX2, during chirp      \n
     *       b15:6  RESERVED                \n
     *  @note : This setting is applicable only in PA and PS loop-back modes. \n
     */
    rlUInt16_t bpmConfig;
    /**
     * @brief  Bits  Digital corrections      \n
                 b0  IQMM correction disable (Applicable only in PS and PA loopback modes, 
                     In case of IF loopback mode, IQMM is disabled by default) \n
                      0 - Enable, 1- Disable  \n
                 b1  Digital Inter-RX Gain and Phase correction disable \n
                      0 - Enable, 1- Disable  \n
              b15:2  RESERVED \n
       @note : This setting is applicable in all loop-back modes \n
     */
    rlUInt16_t digCorrDis;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief   Value   IF Loopback frequency value \n
     *          0       180 kHz   \n
     *          1       240 kHz   \n
     *          2       360 kHz   \n
     *          3       720 kHz   \n
     *          4       1 MHz     \n
     *          5       2 MHz     \n
     *          6       2.5 MHz   \n
     *          7       3 MHz     \n
     *          8       4.02 MHz  \n
     *          9       5 MHz     \n
     *          10      6 MHz     \n
     *          11      8.03 MHz  \n
     *          12      9 MHz     \n
     *          13      10 MHz    \n
     *          255-14  RESERVED  \n
     */
    rlUInt8_t  ifLbFreq;
    /**
     * @brief   1 LSB = 10 mV
                Valid range: 1 to 63
     */
    rlUInt8_t  ifLbMag;
    /**
     * @brief Programmable Gain Amplifier Setting: This configures the Phase shifter loopback 
     *        path amplifier gain for TX0 based PS loopback.
     *        Value PGA gain value \n
     *          0   PGA is OFF     \n
     *          1   -22 dB         \n
     *          2   -16 dB         \n
     *          3   -15 dB         \n
     *          4   -14 dB         \n
     *          5   -13 dB         \n
     *          6   -12 dB         \n
     *          7   -11 dB         \n
     *          8   -10 dB         \n
     *          9    -9 dB         \n
     *          10   -8 dB         \n
     *          11   -7 dB         \n
     *          12   -6 dB         \n
     *          13   -5 dB         \n
     *          14   -4 dB         \n
     *          15   -3 dB         \n
     *          16   -2 dB         \n
     *          17   -1 dB         \n
     *          18    0 dB         \n
     *          19    1 dB         \n
     *          20    2 dB         \n
     *          21    3 dB         \n
     *          22    4 dB         \n
     *          23    5 dB         \n
     *          24    6 dB         \n
     *          25    7 dB         \n
     *          26    8 dB         \n
     *          27    9 dB         \n
     *          255-28   RESERVED  \n
     */
    rlUInt8_t  ps1PgaIndx;
    /**
     * @brief Same as above definition
     */
    rlUInt8_t  ps2PgaIndx;
#else
    /**
     * @brief   1 LSB = 10 mV
                Valid range: 1 to 63
     */
    rlUInt8_t  ifLbMag;
    /**
     * @brief   Value   IF Loopback frequency value \n
     *          0       180 kHz   \n
     *          1       240 kHz   \n
     *          2       360 kHz   \n
     *          3       720 kHz   \n
     *          4       1 MHz     \n
     *          5       2 MHz     \n
     *          6       2.5 MHz   \n
     *          7       3 MHz     \n
     *          8       4.02 MHz  \n
     *          9       5 MHz     \n
     *          10      6 MHz     \n
     *          11      8.03 MHz  \n
     *          12      9 MHz     \n
     *          13      10 MHz    \n
     *          255-14  RESERVED  \n
     */
    rlUInt8_t  ifLbFreq;
    /**
     * @brief Same as above definition
     */
    rlUInt8_t  ps2PgaIndx;
    /**
     * @brief Programmable Gain Amplifier Setting: This configures the Phase shifter loopback 
     *        path amplifier gain for TX0 based PS loopback.
     *        Value PGA gain value \n
     *         0   PGA is OFF     \n
     *         1   -22 dB         \n
     *         2   -16 dB         \n
     *         3   -15 dB         \n
     *         4   -14 dB         \n
     *         5   -13 dB         \n
     *         6   -12 dB         \n
     *         7   -11 dB         \n
     *         8   -10 dB         \n
     *         9    -9 dB         \n
     *         10   -8 dB         \n
     *         11   -7 dB         \n
     *         12   -6 dB         \n
     *         13   -5 dB         \n
     *         14   -4 dB         \n
     *         15   -3 dB         \n
     *         16   -2 dB         \n
     *         17   -1 dB         \n
     *         18    0 dB         \n
     *         19    1 dB         \n
     *         20    2 dB         \n
     *         21    3 dB         \n
     *         22    4 dB         \n
     *         23    5 dB         \n
     *         24    6 dB         \n
     *         25    7 dB         \n
     *         26    8 dB         \n
     *         27    9 dB         \n
     *         255-28   RESERVED  \n
     */
    rlUInt8_t  ps1PgaIndx;
#endif
    /**
     * @brief Phase shifter loop back frequency in kHz: The TX phase shifter's phase shift 
              command word is linearly varied at a rate configured by this field to achieve a 
              frequency shift. \n
                1 LSB = 1 kHz                         \n
                Bits    Definition                    \n
                b15:0   TX0 Loopback Frequency        \n
                b31:16  TX1 Loopback Frequency        \n
     */
    rlUInt32_t psLbFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved3;
    /**
     * @brief This value is a 100MHz divider which sets the loopback frequency: The PA output is 
              fed to a modulator before coupling to the RX LNA input. This field govern the 
              modulation frequency and can be used to separate the internal loopback signal from 
              external reflections wrt IF frequency at the Receiver. \n
               For e.g. for a 1 MHz frequency, set this to 100 \n
                        for a 2 MHz frequency, set this to 50  \n
               @note : To ensure no leakage of signal power, user has to ensure that
                       100MHz/LOOPBACK_FREQ is an integer multiple of bin width. \n
                       For e.g. if user choses 25Msps sampling rate and 2048 samples/chirp,
                       then LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage.
     */
    rlUInt16_t paLbFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved4[3U];
} rlLoopbackBurst_t;

/*! \brief
* Chirp row configuration, radarSS stores each chirp config in memory in 3 rows.
*/
typedef struct rlChirpRow
{
    /**
     * @brief Nth Chirp config Row 1
                 Bits Definition
                  3:0 PROFILE_INDX
                       Valid range 0 to 3
                  7:4 RESERVED
                  13:8 FREQ_SLOPE_VAR
                       For 77GHz Devices (76GHz to 81GHz):
                           1 LSB = 3.6e9*900 /2^26  ~48.279kHz
                           Valid range: 0 to 63
                       For 60GHz Devices (57GHz to 64GHz):
                           1 LSB = 2.7e9*900 /2^26  ~36.21kHz
                           Valid range: Only even numbers from 0 to 63
                  15:14 RESERVED
                  18:16 TX_ENABLE
                         Bit Definition
                          b0 TX0 Enable
                          b1 TX1 Enable
                          b2 TX2 Enable
                  23:19 RESERVED
                  29:24 RESERVED
                  31:30 RESERVED
     */
    rlUInt32_t chirpNR1;
    /**
     * @brief Nth Chirp config Row 2
                 Bits Definition
                 b22:0 FREQ_START_VAR
                   1 LSB = 3.6e9/2^26  ~53.644kHz
                    Valid range: 0 to 8388607
                 b31:23 RESERVED
    */
    rlUInt32_t chirpNR2;
    /**
     * @brief Nth Chirp config Row 3
                 Bits Definition
                 b11:0 IDLE_TIME_VAR
                        1 LSB = 10 ns
                        Valid range: 0 to 4095
                 b15:12 RESERVED
                 b27:16 ADC_START_TIME_VAR
                        1 LSB = 10 ns
                        Valid range: 0 to 4095
                 b31:28 RESERVED
    */
    rlUInt32_t chirpNR3;
} rlChirpRow_t;

/*! \brief
* Dynamic chirp configuration for 16 chirp configurations.
*/
typedef struct rlDynChirpCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
               Bits   Definition
               b3:0   Reserved
               b7:4   If user does not wish to reconfigure all 3 chirp rows, then the following \n
                      mode can be used to configure only one row per chirp which enables the \n
                      user to configure 48 chirps in one API, efectively saving on the \n
                      reconfiguration time. If chirpRowSelect[b7:4] is non-zero, then the API \n
                      parameters chirp_xR1, chirp_xR2 and chirp_xR3 for 1 <= x <= 16 in this \n
                      API would mean CHIRP(3x - 2)Ry, CHIRP(3x - 1) Ry and CHIRP(3x)Ry where y \n
                      is as per the below table \n
                      Value         Definition \n
                      0b0000        Enables all 3 chirp rows to be reconfigured \n
                      0b0001        Enables only chirp row 1 to be reconfigured \n
                      0b0010        Enables only chirp row 2 to be reconfigured \n
                      0b0011        Enables only chirp row 3 to be reconfigured \n
                      Others        Reserved \n
     */
    rlUInt8_t    chirpRowSelect;
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM.
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
#else
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM.
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
    /**
     * @brief  Reserved for Future use
               Bits   Definition
               b3:0   Reserved
               b7:4   If user does not wish to reconfigure all 3 chirp rows, then the following \n
                      mode can be used to configure only one row per chirp which enables the \n
                      user to configure 48 chirps in one API, efectively saving on the \n
                      reconfiguration time. If chirpRowSelect[b7:4] is non-zero, then the API \n
                      parameters chirp_xR1, chirp_xR2 and chirp_xR3 for 1 <= x <= 16 in this \n
                      API would mean CHIRP(3x - 2)Ry, CHIRP(3x - 1) Ry and CHIRP(3x)Ry where y \n
                      is as per the below table \n
                      Value         Definition \n
                      0b0000        Enables all 3 chirp rows to be reconfigured \n
                      0b0001        Enables only chirp row 1 to be reconfigured \n
                      0b0010        Enables only chirp row 2 to be reconfigured \n
                      0b0011        Enables only chirp row 3 to be reconfigured \n
                      Others        Reserved \n
     */
    rlUInt8_t    chirpRowSelect;
#endif
    /**
     * @brief  Indicates when the configuration needs to be applied \n
     *         Bit    Definition \n
     *          0     Program the new configuration when rlSetDynChirpEn API is issued \n
     *          1     Program the new configuration immediately \n
     *                @note : User has to ensure that the chirps which are being reconfigured are
     *                not the ones which are currently in use for chirping
     */
    rlUInt16_t   programMode;
    /**
     * @brief Chirp row configurations for 16 chirps.
     */
    rlChirpRow_t chirpRow[16U];
} rlDynChirpCfg_t;

/*! \brief
* Dynamic chirp enable configuration
*/
typedef struct rlDynChirpEnCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved;
}rlDynChirpEnCfg_t;

/*! \brief
* Dynamic per chirp phase shifter configuration for each TX
*/
typedef struct rlChirpPhShiftPerTx
{
    /**
     * @brief Nth Chirp TX0 phase shift value
                Bits TX0 phase shift definition
                b1:0 RESERVED (set it to 0b00)
                b7:2 TX0 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx0PhaseShifter;
    /**
     * @brief Nth Chirp TX1 phase shift value
                Bits TX1 phase shift definition
                b1:0 RESERVED (set it to 0b00)
                b7:2 TX1 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx1PhaseShifter;
    /**
     * @brief Nth Chirp TX2 phase shift value   \n
                Bits TX2 phase shift definition \n
                b1:0 RESERVED (set it to 0b00)  \n
                b7:2 TX2 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx2PhaseShifter;
} rlChirpPhShiftPerTx_t;

/*! \brief
* Dynamic per chirp phase shifter configuration
*/
typedef struct rlDynPerChirpPhShftCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t    reserved;
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM. \n
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
#else
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM. \n
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t    reserved;
#endif
    /**
     * @brief Tx phase shifter configurations for 16 chirps.
              @note : User need to take care of data for endianess.
     */
    rlChirpPhShiftPerTx_t phShiftPerTx[16U];
    /**
     * @brief  Indicates when the configuration needs to be applied \n
     *         Bit    Definition \n
     *          0     Program the new configuration when rlSetDynChirpEn API is issued \n
     *          1     Program the new configuration immediately \n
     *                @note : User has to ensure that the chirps which are being reconfigured are
     *                not the ones which are currently in use for chirping
     */
    rlUInt16_t   programMode;
} rlDynPerChirpPhShftCfg_t;

/*! \brief
* Get calibration data configuration structure
*/
typedef struct rlCalDataGetCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
    /**
     * @brief Get Calibration Data Chunk Id
     */
    rlUInt16_t chunkId;
}rlCalDataGetCfg_t;

/*! \brief
* Calibration data which application will receive from radarSS and will feed in to the Device
* in next power up to avoid calibration.
*/
typedef struct rlCalDataStore
{
    /**
     * @brief Number of calibration data chunks Available in device
     */
    rlUInt16_t numOfChunk;
    /**
     * @brief Current Calibration Data Chunk Id. Valid range 0-2
     */
    rlUInt16_t chunkId;
    /**
     * @brief Calibration data chunk which was stored in non-volatile memory \n
     */
    rlUInt8_t  calData[224U];
} rlCalDataStore_t;

/*! \brief
* Structure to store all Calibration data chunks which device provides in response of
* rlRfCalibDataStore API. Applcation needs to provide same structure to rlRfCalibDataRestore API
* to restore calibration data to the device. \n
* Accumulative calData for 3 chunks (3 * 224 bytes) looks like as mentioned. \n
*
*
*  AWR2243 calibration data structure
*
* Field Name     Num.of bytes  Description \n
* calValidStatus     4         This field indicates the status of each calibration (0 – FAIL, 
*                              1 – PASS). If a particular calibration was not enabled, then its
*                              corresponding field should be ignored. \n
*                              Bit   Definition (0 – FAIL, 1 – PASS) \n
*                              b0    RESERVED \n
*                              b1    APLL tuning (Ignore while restore) \n
*                              b2    SYNTH VCO1 tuning (Ignore while restore) \n
*                              b3    SYNTH VCO2 tuning (Ignore while restore) \n
*                              b4    LODIST calibration (Ignore while restore) \n
*                              b5    RX ADC DC offset calibration \n
*                              b6    HPF cutoff calibration \n
*                              b7    LPF cutoff calibration \n
*                              b8    Peak detector calibration (optional) \n
*                              b9    TX Power calibration (optional) \n
*                              b10   RX gain calibration \n
*                              b11   TX Phase calibration (optional) \n
*                              b12   RX IQMM calibration \n
*                              b31:13 RESERVED
*                              The recommended Validity status bits while restoring
*                              is 0x000014E0, assuming only rxAdcDcCalData,
*                              hpfCalData, lpfCalData, rxRfGainCalData and IQMM
*                              iqmmCalData are stored and restored. \n
* calValidStatusCpy 4          Redundant calValidStatus value, this value should match with
*                              calValidStatus. \n
* reserved          8          Reserved for Future use \n
* calTemperature    2          Temperature at which boot calibration is done. \n
* reserved          14         Reserved for Future use \n
* rxAdcDcCalibData  16         RX chain ADC DC calibration data \n
* hpf1CalData       1          HPF1 calibration data \n
* hpf2CalData       1          HPF2 calibration data \n
* loDistBiasCode    1          LODIST calibration data \n
* loDistFreqIndex   1          LODIST calibration frequency index \n
* reserved          48         Reserved for Future use \n
* rxRfGainCalData   8          RX RF gain calibration data \n
* iqmmCalibData     104        RX IQMM calibration data \n
* txPowCalData      82         TX Power calibration data \n
* powDetCalData     326        Power detector calibration data \n
* reserved          52         Reserved for Future use \n
*
*  xWR6x43 calibration data structure
*
* Field Name     Num.of bytes  Description \n
* calValidStatus     4         This field indicates the status of each calibration (0 – FAIL, 
*                              1 – PASS). If a particular calibration was not enabled, then its
*                              corresponding field should be ignored. \n
*                              Bit   Definition (0 – FAIL, 1 – PASS) \n
*                              b0    SYNTH VCO3 tuning (Available only on selected xWR6243 device 
                                     variants, RESERVED for other 60GHz devices. 
                                     Ignore while store restore) \n
*                              b1    APLL tuning (Ignore while restore) \n
*                              b2    SYNTH VCO1 tuning (Ignore while restore) \n
*                              b3    SYNTH VCO2 tuning (Ignore while restore) \n
*                              b4    LODIST calibration (Ignore while restore) \n
*                              b5    RX ADC DC offset calibration \n
*                              b6    HPF cutoff calibration \n
*                              b7    LPF cutoff calibration \n
*                              b8    Peak detector calibration (optional) \n
*                              b9    TX Power calibration (optional) \n
*                              b10   RX gain calibration \n
*                              b11   TX Phase calibration (Ignore while restore) \n
*                              b12   RX IQMM calibration \n
*                              b31:13 RESERVED
*                              The recommended Validity status bits while restoring
*                              is 0x000014E0, assuming only rxAdcDcCalData,
*                              hpfCalData, lpfCalData, rxRfGainCalData and IQMM
*                              iqmmCalData are stored and restored. \n
* calValidStatusCpy 4          Redundant calValidStatus value, this value should match with
*                              calValidStatus. \n
* reserved          8          Reserved for Future use \n
* calTemperature    2          Temperature at which boot calibration is done. \n
* reserved          14         Reserved for Future use \n
* rxAdcDcCalibData  16         RX chain ADC DC calibration data \n
* hpf1CalData       1          HPF1 calibration data \n
* hpf2CalData       1          HPF2 calibration data \n
* loDistBiasCode    1          LODIST calibration data \n
* reserved          1          Reserved for Future use \n
* rxRfGainCalData   8          RX RF gain calibration data \n
* iqmmCalibData     104        RX IQMM calibration data \n
* txPowCalData      122        TX Power calibration data \n
* powDetCalData     344        Power detector calibration data \n
* reserved          42         Reserved for Future use \n
*/
typedef struct rlCalibrationData
{
     rlCalDataStore_t calibChunk[RL_MAX_CALIB_DATA_CHUNK];
}rlCalibrationData_t;

/*! \brief
* Inter-Rx gain and phase offset configuration
*/
typedef struct rlInterRxGainPhConf
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  This field can be used to enable or disable different digital compensation. \n
               Bits       Assignment \n
                b0        Digital RX gain compensation enable \n
                b1        Digital RX phase compensation enable \n
                b2        Digital RX delay compensation enable \n
                b3        Digital RX frequency shift enable \n
                b4        Digital TX frequency shift enable (for debug purpose only) \n
                b31:5     RESERVED \n
               Value      Description \n
                 0        Disable \n
                 1        Enable \n
     */
    rlUInt8_t  digCompEn;
#else
    /**
     * @brief  This field can be used to enable or disable different digital compensation. \n
               Bits       Assignment \n
                b0        Digital RX gain compensation enable \n
                b1        Digital RX phase compensation enable \n
                b2        Digital RX delay compensation enable \n
                b3        Digital RX frequency shift enable \n
                b4        Digital TX frequency shift enable (for debug purpose only) \n
                b31:5     RESERVED \n
               Value      Description \n
                 0        Disable \n
                 1        Enable \n
     */
    rlUInt8_t  digCompEn;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  The digital gain compensation for each RX channels \n
               One byte per RX (8-bit signed number) \n
                 Byte    Assignment \n
                 0       RX0 digital gain \n
                 1       RX1 digital gain \n
                 2       RX2 digital gain \n
                 3       RX3 digital gain \n
                 1 LSB = 0.1 dB, signed \n
                 Valid Range: -120 to 119 \n
     */
    rlInt8_t   digRxGainComp[RL_RX_CNT];
#else
    /**
     * @brief  The digital gain compensation for each RX channels \n
               One byte per RX (8-bit signed number) \n
                 Byte    Assignment \n
                 0       RX0 digital gain \n
                 1       RX1 digital gain \n
                 2       RX2 digital gain \n
                 3       RX3 digital gain \n
                 1 LSB = 0.1 dB, signed \n
                 Valid Range: -120 to 119 \n
     */
    rlInt8_t   digRxGainComp[RL_RX_CNT];
#endif
    /**
     * @brief  The digital phase shift compensation for each RX channels \n
               Two bytes per RX \n
                 Bits         Assignment \n
                 b15:0        RX0 digital phase shift \n
                 b31:16       RX1 digital phase shift \n
                 b47:32       RX2 digital phase shift \n
                 b63:48       RX3 digital phase shift \n
                 1 LSB = 360 degree / 2^16  ~ 0.0055 (degree), unsigned \n
                 Valid Range: 0 to 65535 \n
                 @note : This field is NOT applicable when ADC_OUT_FMT is 00 (real output) \n
     */
    rlUInt16_t digRxPhShiftComp[RL_RX_CNT];
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  The digital delay compensation for each RX channels \n
               One byte per RX (8-bit unsigned number) \n
                 Byte    Assignment \n
                 0       RX0 digital delay \n
                 1       RX1 digital delay \n
                 2       RX2 digital delay \n
                 3       RX3 digital delay \n
                 1 LSB = 556ps/16, unsigned \n
                 Valid Range: 0 to 255 \n
               The RX ADC output is delayed by this amount. The LSB becomes twice of the above \n
               if ADC low power mode is enabled. \n
     */
    rlUInt8_t   digRxDelayComp[RL_RX_CNT];
#else
    /**
     * @brief  The digital delay compensation for each RX channels \n
               One byte per RX (8-bit unsigned number) \n
                 Byte    Assignment \n
                 0       RX0 digital delay \n
                 1       RX1 digital delay \n
                 2       RX2 digital delay \n
                 3       RX3 digital delay \n
                 1 LSB = 556ps/16, unsigned \n
                 Valid Range: 0 to 255 \n
               The RX ADC output is delayed by this amount. The LSB becomes twice of the above \n
               if ADC low power mode is enabled. \n
     */
    rlUInt8_t   digRxDelayComp[RL_RX_CNT];
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t  reserved2[4U];
    /**
     * @brief  The digital frequency shift compensation for each RX channels \n
               Two bytes per RX \n
                 Bits         Assignment \n
                 b15:0        RX0 digital frequency shift \n
                 b31:16       RX1 digital frequency shift \n
                 b47:32       RX2 digital frequency shift \n
                 b63:48       RX3 digital frequency shift \n
                 1 LSB = (ADC Sampling Rate Hz*floor(100MHz/ADC Sampling Rate Hz))*1/2^16,signed \n
                 Valid Range: -32768 to 32767 \n
               The frequency range of interest in RX digital output is shifted by this amount. \n
               As an example, this may be used to view the spectrum beyond the conventional \n
               [0 to Output Sampling Rate] range in Complex 1X mode, say [FREQ_SHIFT to Output \n
               Sampling Rate + FREQ_SHIFT]. \n
               @note :  This field is NOT applicable when ADC_OUT_FMT is 00 (real output). 
     */
    rlInt16_t digRxFreqShift[RL_RX_CNT];
    /**
     * @brief  The digital frequency shift compensation for each TX channels, this is supported \n
               only for TX0 and TX1 in AWR2243. xWR6243 supports digital frequency shift for all \n
               3 TX channels. \n
               Two bytes per TX \n
                 Bits         Assignment \n
                 b15:0        TX0 digital frequency shift \n
                 b31:16       TX1 digital frequency shift \n
                 b47:32       TX2 digital frequency shift (RESERVED for AWR2243) \n
                 b63:48       RESERVED \n
                 1 LSB = 100MHz/2^16, signed \n
                 Valid Range: -32768 to 32767 \n
               The frequency of the TX output may be shifted wrt the RX mixer LO frequency by \n
               this amount. If such functionality is not desired, this register should be set \n
               to 0. This register cannot be used in conjunction with TX phase shifter. \n \n
               This may be useful in factory calibration of IF frequency dependent effects. \n
               As an example, in cascaded applications, the IF frequency at which a corner \n
               reflector’s beat frequency appears at the RX mixer output can be varied using \n
               this and cascade RX IF imbalances can be measured. \n
       @note : The TX frequency shifting involves some sharing of digital modulation hardware, \n
               which imposes following constraints: \n
               - Not more than 2 distinct non-zero values can be set in DIGITAL_TX_FREQ_SHIFT 
               TX0, TX1, TX2 \n
               - Not more than 2 TX's in the device can be simultaneously enabled in the \n
               Chirp Configuration API's if using DIGITAL_TX_FREQ_SHIFT in this API. \n
     */
    rlInt16_t digTxFreqShift[RL_RX_CNT];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t  reserved3[4U];
} rlInterRxGainPhConf_t;

/*! \brief
 * BSS Bootup status data structure
 */
typedef struct rlRfBootStatusCfg
{
    /**
     * @brief radarSS bootup status
                Bit     definition [1: pass, 0: fail]
                0       image CRC validation
                1       CPU and VIM self-test status
                2       Reserved
                3       VIM test
                4       STC self-test
                5       CR4 STC
                6       CRC test
                7       Pampgen ECC
                8       Reserved
                9       DFE ECC
                10      Rampgen Lockstep
                11      FRC lockstep
                12      DFE PBIST
                13      Rampgen lockstep
                14      PBIST test
                15      WDT test
                16      ESM test
                17      DFE STC
                18      FRC test
                19      TCM ECC
                20      TCM parity
                21      DCC test (Supported only on AWR2243/xWR6243 device)
                22      SOCC test
                23      GPADC test
                24      FFT test
                25      RTI test
                26      PCR test
                31:27   reserved
     */
    rlUInt32_t bssSysStatus;
    /**
     * @brief RF BIST SS power up time \n
                1 LSB = 5ns
     */
    rlUInt32_t bssBootUpTime;
        /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
}rlRfBootStatusCfg_t;

/*! \brief
* Inter Chirp block control configuration
*/
typedef struct rlInterChirpBlkCtrlCfg
{
    /**
     * @brief Time to wait after ramp end before turning off RX0 and RX2 RF stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02RfTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX1 and RX3 RF stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13RfTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX0 and RX2 baseband stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX1 and RX3 baseband stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx12BbTurnOffTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 RF stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02RfPreEnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 RF stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13RfPreEnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbPreEnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13BbPreEnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 RF stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
    */
    rlInt16_t rx02RfTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 RF stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
    */
    rlInt16_t rx13RfTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13BbTurnOnTime;
    /**
     * @brief Time to wait after ramp end before turning off RX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rxLoChainTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off TX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t txLoChainTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning on RX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rxLoChainTurnOnTime;
    /**
     * @brief Time to wait after ramp end before turning on TX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t txLoChainTurnOnTime;
    /**
     * @brief  Reserved for Future use
     */
    rlInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlInt32_t reserved1;
} rlInterChirpBlkCtrlCfg_t;

/*! \brief
* Sub-frame trigger API
*/
typedef struct rlSubFrameStartCfg
{
    /**
     * @brief Command for sub-frame trigger     \n
              Value 0 = No effect               \n
              Value 1 = Trigger next sub-frame  \n
     */
    rlUInt16_t startCmd;
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved;
} rlSubFrameStartCfg_t;

/*! \brief
* Get phase shift calibration data configuration structure
*/
typedef struct rlPhShiftCalDataGetCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443, xWR1243, xWR2243 & \n
               xWR6243). \n
     */
    rlUInt8_t txIndex;
    /**
     * @brief Reserved for future use
     */
    rlUInt8_t reserved0;
#else
    /**
     * @brief Reserved for future use
     */
    rlUInt8_t reserved0;
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443, xWR1243, xWR2243 & \n
               xWR6243). \n
     */
    rlUInt8_t txIndex;
#endif
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved1;
}rlPhShiftCalDataGetCfg_t;

/*! \brief
* Phase shift calibration data which application will receive from radarSS and will feed in to the
* Device in next power up to avoid calibration.
*/
typedef struct rlPhShiftCalibrationStore
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443, xWR1243, xWR2243 & \n
               xWR6243). \n
     */
    rlUInt8_t txIndex;
    /**
     * @brief Set this to 1 after injecting calibration data for all Txs to enable the firmware \n
*             calibration. \n
     */
    rlUInt8_t calibApply;
#else
    /**
    * @brief Set this to 1 after injecting calibration data for all Txs to enable the firmware \n
             calibration. \n
    */
    rlUInt8_t calibApply;
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443, xWR1243, xWR2243 & \n
               xWR6243). \n
     */
    rlUInt8_t txIndex;
#endif
    /**
     * @brief Observed phase shift corresponding to each desired phase shift. Index n \n
        corresponds to desired phase shift of n * 5.625 degree. \n
        For TX0, for phase shifter setting/index n=0 to 63 corresponding to functional APIs 
        (e.g. Profile Config, Per Chirp Phase Shifter, etc), the calibration data needs to be 
        retrieved from/restored to following byte locations of TX0 phase calibration data 
        save/restore API: \n
        n     Desired phase shift   Observed phase shift is injected in the following bytes \n
        17    17*5.625 degrees               byte[1], byte[0]     \n
        18    18*5.625 degrees               byte[3], byte[2]     \n
        :          :                                :             \n
        :          :                                :             \n
        62    62*5.625 degrees               byte[91], byte[90]   \n
        63    63*5.625 degrees               byte[93], byte[92]   \n
        0      0*5.625 degrees               byte[95], byte[94]   \n
        1      1*5.625 degrees               byte[97], byte[96]   \n
        :          :                                :             \n
        :          :                                :             \n
        15    15*5.625 degrees               byte[125], byte[124] \n
        16    16*5.625 degrees               byte[127], byte[126] \n
        For TX1 and TX2, for phase shifter setting/index n=0 to 63 corresponding to functional 
        APIs (e.g. Profile Config, Per Chirp Phase Shifter, etc), the calibration data needs to 
        be retrieved from/restored to following byte locations of TX1 and TX2 phase calibration 
        data save/restore API: \n
        n     Desired phase shift   Observed phase shift is injected in the following bytes \n
        49    49*5.625 degrees               byte[1], byte[0]     \n
        50    50*5.625 degrees               byte[3], byte[2]     \n
        :          :                                :             \n
        :          :                                :             \n
        62    62*5.625 degrees               byte[27], byte[26]   \n
        63    63*5.625 degrees               byte[29], byte[28]   \n
        0      0*5.625 degrees               byte[31], byte[30]   \n
        1      1*5.625 degrees               byte[33], byte[32]   \n
        :          :                                :             \n
        :          :                                :             \n
        47    47*5.625 degrees               byte[125], byte[124] \n
        48    48*5.625 degrees               byte[127], byte[126] \n
              1 LSB = (360 degree)/pow(2,10). \n
     */
    rlUInt8_t  observedPhShiftData[128U];
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved;
} rlPhShiftCalibrationStore_t;

/*! \brief
* Structure to store all Phase shifter calibration data chunks which device provides in response of
* rlRfPhShiftCalibDataStore API. Applcation needs to provide same structure to
* rlRfPhShiftCalibDataRestore API to restore calibration data to the device.
*/
typedef struct rlPhShiftCalibrationData
{
     rlPhShiftCalibrationStore_t PhShiftcalibChunk[RL_TX_CNT];
}rlPhShiftCalibrationData_t;

/*! \brief
* Die ID data structure
*/
typedef struct rlRfDieIdCfg
{
    /**
    * @brief Die ID Hex Value 0
    */
    rlUInt32_t dieIDHexVal0;
    /**
    * @brief Die ID Hex Value 1
    */
    rlUInt32_t dieIDHexVal1;
    /**
    * @brief Die ID Hex Value 2
    */
    rlUInt32_t dieIDHexVal2;
    /**
    * @brief Die ID Hex Value 3
    */
    rlUInt32_t dieIDHexVal3;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved0;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved1;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved2;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved3;
}rlRfDieIdCfg_t;

/*! \brief
* Advanced chirp configuration structure
*/
typedef struct rlAdvChirpCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
    * @brief Chirp parameter that the current API configures. The mapping and availability of 
    *        dither modes are as below: \n
    *        Index     Parameter                  Delta Dither          LUT Dither  \n
    *        0         CHIRP_PROFILE_SELECT            NO                   YES     \n
    *        1         CHIRP_FREQ_START_VAR           YES                   YES     \n
    *        2         CHIRP_FREQ_SLOPE_VAR           YES                   YES     \n
    *        3         CHIRP_IDLE_TIME_VAR            YES                   YES     \n
    *        4         CHIRP_ADC_START_TIME_VAR       YES                   YES     \n
    *        5         CHIRP_TX_EN                     NO                   YES     \n
    *        6         CHIRP_BPM_VAL                   NO                   YES     \n
    *        7         TX0_PHASE_SHIFTER              YES                   YES     \n
    *        8         TX1_PHASE_SHIFTER              YES                   YES     \n
    *        9         TX2_PHASE_SHIFTER              YES                   YES     \n
    *        Others    Reserved \n
    *  The parameters referred to here are the same as the ones with the name referred to in
    *  AWR_CHIRP_CONF_SET_SB and in AWR_PERCHIRPPHASESHIFT_CONF_SB. \n
    */
    rlUInt8_t chirpParamIdx;
    /**
    * @brief Reset mode of the programmed pattern \n
    *        Mode      Definition \n
    *        0         Reset at end of frame \n
    *        1         Reset at end of sub-frame \n
    *        2         Reset at end of burst \n
    *        Others    Reserved \n
    *  It indicates when the fixed delta accumulation (Delta Dither) or the programmed dither 
    *  pattern from LUT (LUT Dither) resets back to its initial value. This is a global reset 
    *  occurs for all the chirp parameters. This value should be same for all chirp parameter. \n
    */
    rlUInt8_t resetMode;
#else
    /**
    * @brief Reset mode of the programmed pattern \n
    *        Mode      Definition \n
    *        0         Reset at end of frame \n
    *        1         Reset at end of sub-frame \n
    *        2         Reset at end of burst \n
    *        Others    Reserved \n
    *  It indicates when the fixed delta accumulation (Delta Dither) or the programmed dither 
    *  pattern from LUT (LUT Dither) resets back to its initial value. This is a global reset 
    *  occurs for all the chirp parameters. This value should be same for all chirp parameter. \n
    */
    rlUInt8_t resetMode;
    /**
    * @brief Chirp parameter that the current API configures. The mapping and availability of 
    *        dither modes are as below: \n
    *        Index     Parameter                  Delta Dither          LUT Dither  \n
    *        0         CHIRP_PROFILE_SELECT            NO                   YES     \n
    *        1         CHIRP_FREQ_START_VAR           YES                   YES     \n
    *        2         CHIRP_FREQ_SLOPE_VAR           YES                   YES     \n
    *        3         CHIRP_IDLE_TIME_VAR            YES                   YES     \n
    *        4         CHIRP_ADC_START_TIME_VAR       YES                   YES     \n
    *        5         CHIRP_TX_EN                     NO                   YES     \n
    *        6         CHIRP_BPM_VAL                   NO                   YES     \n
    *        7         TX0_PHASE_SHIFTER              YES                   YES     \n
    *        8         TX1_PHASE_SHIFTER              YES                   YES     \n
    *        9         TX2_PHASE_SHIFTER              YES                   YES     \n
    *        Others    Reserved \n
    *  The parameters referred to here are the same as the ones with the name referred to in
    *  AWR_CHIRP_CONF_SET_SB and in AWR_PERCHIRPPHASESHIFT_CONF_SB. \n
    */
    rlUInt8_t chirpParamIdx;
#endif
    /**
    * @brief Reserved for future use
    */
    rlUInt16_t reserved0;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved1;
    /**
    * @brief Reset the delta increment (Delta Dither) sequence every M chirps \n
    *        Index     Parameter \n
    *        0         Reset only as per RESET MODE option \n
    *        1         Delta increment is disabled \n
    *        2-32768   Reset every M chirps in addition to RESET MODE option \n
    *  The reset period should be integer multiple of DELTA_PARAM_UPDATE_PERIOD (N) \n
    *  Range : 0-32768 \n
    */
    rlUInt16_t deltaResetPeriod;
    /**
    * @brief The chirp parameter will be incremented by SFn_CHIRP_PARAM_DELTA (Delta Dither) every 
    *        N chirps. \n
    *        Index     Parameter \n
    *        0         Delta increment is disabled \n
    *        1-N       The fixed delta value will be incremented once after every N chirps. \n
    *  Range : 0-16384 \n
    */
    rlUInt16_t deltaParamUpdatePeriod;
    /**
    * @brief This field indicates the delta increment (Delta Dither) value for sub-frame 0 
    *        (Also applicable for legacy frame config API) that should be accumulated and added to 
    *        each chirp based on update period N. \n
    *        This accumulated fixed dither value which increments every N chirps is added to LUT 
    *        dither value derived for same chirp, The sum of accumulated dither and LUT dither 
    *        derived for each chirp is added to profile setting of same chirp parameter in HW. \n
    *        As some parameters may need signed values, all the Bytes in this field should be
    *        populated with appropriate sign extension. \n
    *        Refer to the Fixed Delta Chirp Parameter LUT description table Table for the 
    *        definition of this field when each parameter is selected. This feature is enabled 
    *        only for certain chirp parameter types as defined in this table. \n
    */
    rlInt32_t sf0ChirpParamDelta;
    /**
    * @brief This field indicates the delta increment (Delta Dither) value for sub-frame 1 
    *        (Also applicable for legacy frame config API) that should be accumulated and added to 
    *        each chirp based on update period N. \n
    *        This accumulated fixed dither value which increments every N chirps is added to LUT 
    *        dither value derived for same chirp, The sum of accumulated dither and LUT dither 
    *        derived for each chirp is added to profile setting of same chirp parameter in HW. \n
    *        As some parameters may need signed values, all the Bytes in this field should be
    *        populated with appropriate sign extension. \n
    *        Refer to the Fixed Delta Chirp Parameter LUT description table Table for the 
    *        definition of this field when each parameter is selected. This feature is enabled 
    *        only for certain chirp parameter types as defined in this table. \n
    */
    rlInt32_t sf1ChirpParamDelta;
    /**
    * @brief This field indicates the delta increment (Delta Dither) value for sub-frame 2 
    *        (Also applicable for legacy frame config API) that should be accumulated and added to 
    *        each chirp based on update period N. \n
    *        This accumulated fixed dither value which increments every N chirps is added to LUT 
    *        dither value derived for same chirp, The sum of accumulated dither and LUT dither 
    *        derived for each chirp is added to profile setting of same chirp parameter in HW. \n
    *        As some parameters may need signed values, all the Bytes in this field should be
    *        populated with appropriate sign extension. \n
    *        Refer to the Fixed Delta Chirp Parameter LUT description table Table for the 
    *        definition of this field when each parameter is selected. This feature is enabled 
    *        only for certain chirp parameter types as defined in this table. \n
    */
    rlInt32_t sf2ChirpParamDelta;
    /**
    * @brief This field indicates the delta increment (Delta Dither) value for sub-frame 3 
    *        (Also applicable for legacy frame config API) that should be accumulated and added to 
    *        each chirp based on update period N. \n
    *        This accumulated fixed dither value which increments every N chirps is added to LUT 
    *        dither value derived for same chirp, The sum of accumulated dither and LUT dither 
    *        derived for each chirp is added to profile setting of same chirp parameter in HW. \n
    *        As some parameters may need signed values, all the Bytes in this field should be
    *        populated with appropriate sign extension. \n
    *        Refer to the Fixed Delta Chirp Parameter LUT description table Table for the 
    *        definition of this field when each parameter is selected. This feature is enabled 
    *        only for certain chirp parameter types as defined in this table. \n
    */
    rlInt32_t sf3ChirpParamDelta;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved2;
    /**
    * @brief Reset the LUT sequence (LUT Dither) every J chirps \n
    *        Index     Parameter \n
    *        0         Reset only as per RESET MODE option \n
    *        1         Fixed 0th indexed LUT value programmed for all chirps \n
    *        2-32768   Reset every M chirps in addition to RESET MODE option \n
    *  The reset period should be integer multiple of LUT_PARAM_UPDATE_PERIOD (K) \n
    *  Range : 0-32768 \n
    */
    rlUInt16_t lutResetPeriod;
    /**
    * @brief The chirp parameter (LUT Dither) will be updated with new value from LUT every K 
    *        chirps. \n
    *        Index     Parameter \n
    *        0         Fixed 0th indexed LUT value programmed for all chirps \n
    *        1-K       Index to LUT will be incremented once after every K chirps and
    *                  corresponding LUT value is used. \n
    *  Range : 0-16384 \n
    */
    rlUInt16_t lutParamUpdatePeriod;
    /**
    * @brief This field provides the start address offset within the Generic SW Chirp Parameter 
    *        LUT which holds dither parameters (LUT Dither) for this CHIRP_PARAM_INDEX. \n
    *        The first chirp of the burst/frame picks the dither from 0th index to LUT with this 
    *        address offset and dithers for next chirps will be derived based on pattern 
    *        configuration defined in this API. \n
    *        Address offset has to be multiple 4 bytes (word boundary) \n
    *        The Generic SW chirp parameters are described in Table and it can be loaded in to LUT
    *        using AWR_ADVANCE_CHIRP_GENERIC_LUT_LOAD_SB API. \n
    */
    rlUInt16_t lutPatternAddressOffset;
    /**
    * @brief This field provides the number of unique dither parameters present in LUT. \n
    *        This information is used to perform out of bound error check on index to LUT. 
    *        (LUT Dither) \n
    *  Range : 1-8192 \n
    */
    rlUInt16_t numOfPatterns;
    /**
    * @brief This field provides the LUT index start offset for subsequent bursts in advanced 
    *        frame config API. The chirp LUT start index for each burst is determined as the chirp 
    *        LUT start index of the previous burst plus BURST_LUT_INDEX_OFFSET. This feature helps 
    *        to loop set of different chirps in subsequent bursts in a sub-frame. \n
    *        Only relevant when using Advanced Frame Config API. Provides flexibility to have an 
    *        offset in index to LUT (LUT Dither) from one burst to the next burst. \n
    *        Index     Parameter \n
    *        0         No offset (default) \n
    *        1-P       LUT index start offset for each burst \n
    *        @note 1 : The first burst in second or higher sub-frame is always indexing to 
    *                  SF_LUT_INDEX_OFFSET parameter in LUT. \n
    *        @note 2 : The LUT_RESET_PERIOD can not be more than number of chirps in a burst if 
    *                  this feature is used. \n
    */
    rlUInt16_t lutBurstIndexOffset;
    /**
    * @brief This field provides the LUT index start offset for subsequent sub-frames in advanced 
    *        frame config API. The chirp LUT start index for first burst in each SF is determined 
    *        as the chirp LUT start index of the previous SF plus SF_LUT_INDEX_OFFSET. This 
    *        feature helps to loop set of different chirps in subsequent sub-frames. \n
    *        Only relevant when using Advanced Frame Config API. Provides flexibility to have an 
    *        offset in index to LUT (LUT Dither) from one subframe to the next subframe. \n
    *        Index     Parameter \n
    *        0         No offset (default) \n
    *        1-P       LUT index start offset for each sub-frame (SF) \n
    *        @note 1 : The first SF in advance frame is always indexing to 0th parameter in LUT. \n
    *        @note 2 : The LUT_RESET_PERIOD can not be more than number of chirps in a sub-frame 
    *                  if this feature is used. \n
    */
    rlUInt16_t lutSfIndexOffset;
#ifndef MMWL_BIG_ENDIAN
    /**
    * @brief This field is applicable only for LUT chirp parameters (LUT Dither) of type 
    *        CHIRP_FREQ_START_VAR or CHIRP_IDLE_TIME_VAR or CHIRP_ADC_START_TIME_VAR. This feature 
    *        can be used to reduce the size of the parameter in LUT if dynamic range of parameter 
    *        is small. \n
    *        LUT_CHIRP_PARAM_SIZE        0         1         2        \n
    *        CHIRP_FREQ_START_VAR      4 bytes   2 bytes   1 byte     \n
    *        CHIRP_IDLE_TIME_VAR       2 bytes   1 byte      -        \n
    *        CHIRP_ADC_START_TIME_VAR  2 bytes   1 byte      -        \n
    *  Range : 0-2 \n
    *  Default Value : 0 (default size) \n
    */
    rlUInt8_t lutChirpParamSize;
    /**
    * @brief This field is applicable only for LUT chirp parameters (LUT Dither) of type 
    *        CHIRP_FREQ_START_VAR or CHIRP_IDLE_TIME_VAR or CHIRP_ADC_START_TIME_VAR. This feature 
    *        can be used to reduce the size of the parameter in LUT if granularity of the 
    *        resolution can be increased. \n
    *  Range : 0-16 \n
    *  The actual parameter value for the defined chirp is given by:
    *  2^ LUT_CHIRP_PARAM_SCALE * LUT_PARAM_VALUE \n
    *  Default Value : 0 (no scale) \n
    */
    rlUInt8_t lutChirpParamScale;
#else
    /**
    * @brief This field is applicable only for LUT chirp parameters (LUT Dither) of type 
    *        CHIRP_FREQ_START_VAR or CHIRP_IDLE_TIME_VAR or CHIRP_ADC_START_TIME_VAR. This feature 
    *        can be used to reduce the size of the parameter in LUT if granularity of the 
    *        resolution can be increased. \n
    *  Range : 0-16 \n
    *  The actual parameter value for the defined chirp is given by:
    *  2^ LUT_CHIRP_PARAM_SCALE * LUT_PARAM_VALUE \n
    *  Default Value : 0 (no scale) \n
    */
    rlUInt8_t lutChirpParamScale;
    /**
    * @brief This field is applicable only for LUT chirp parameters (LUT Dither) of type 
    *        CHIRP_FREQ_START_VAR or CHIRP_IDLE_TIME_VAR or CHIRP_ADC_START_TIME_VAR. This feature 
    *        can be used to reduce the size of the parameter in LUT if dynamic range of parameter 
    *        is small. \n
    *        LUT_CHIRP_PARAM_SIZE        0         1         2        \n
    *        CHIRP_FREQ_START_VAR      4 bytes   2 bytes   1 byte     \n
    *        CHIRP_IDLE_TIME_VAR       2 bytes   1 byte      -        \n
    *        CHIRP_ADC_START_TIME_VAR  2 bytes   1 byte      -        \n
    *  Range : 0-2 \n
    *  Default Value : 0 (default size) \n
    */
    rlUInt8_t lutChirpParamSize;
#endif
    /**
    * @brief This field is applicable only if SFn_CHIRP_PARAM_DELTA increment (Delta Dither) is 
    *        enabled for Phase shifter dithers. It controls the TX phase quantization. The device
    *        internal TX phase shifters are 6 bit. For deriving the internal 6 bit phase, the 16 
    *        bit CHIRP_PARAM_DELTA is accumulated in the firmware every chirp. The accumulator’s
    *        output is added with a random number from 0 to this field’s value. The 6 MSBs of the
    *        adder’s output are used as the internal 6 bit phase for that chirp. \n
    *  Range : 0-4096 \n
    *  Default Value : 0 (no dither) \n
    */
    rlUInt16_t maxTxPhShiftIntDither;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved3;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved4;
}rlAdvChirpCfg_t;

/*! \brief
* Monitor Type Trigger configuration structure
*/
typedef struct rlMonTypeTrigCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
    * @brief Monitor trigger type to control sequence of execution of monitors \n
    *        Bit       Definition \n
    *        0         Trigger Type 0 monitors \n
    *        1         Trigger Type 1 monitors \n
    *        2         Trigger Type 2 monitors \n
    *        7:3       Reserved \n
    */
    rlUInt8_t monTrigTypeEn;
    /**
    * @brief Reserved for future use
    */
    rlUInt8_t reserved0;
#else
    /**
    * @brief Reserved for future use
    */
    rlUInt8_t reserved0;
    /**
    * @brief Monitor trigger type to control sequence of execution of monitors \n
    *        Bit       Definition \n
    *        0         Trigger Type 0 monitors \n
    *        1         Trigger Type 1 monitors \n
    *        2         Trigger Type 2 monitors \n
    *        7:3       Reserved \n
    */
    rlUInt8_t monTrigTypeEn;
#endif
    /**
    * @brief Reserved for future use
    */
    rlUInt16_t reserved1[3U];
}rlMonTypeTrigCfg_t;

/*! \brief
* APLL Synthesizer Bandwidth Control
*/
typedef struct rlRfApllSynthBwControl
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Synth ICP trim code \n
     */
    rlUInt8_t synthIcpTrim;
    /**
     * @brief  Synth RZ trim code \n
     */
    rlUInt8_t synthRzTrim;
    /**
     * @brief  APLL ICP trim code \n
     */
    rlUInt8_t apllIcpTrim;
    /**
     * @brief  APLL RZ LPF trim code \n
     */
    rlUInt8_t apllRzTrimLpf;
    /**
     * @brief  APLL RZ VCO trim code \n
     *         AWR2243 device: \n
     *           Value        Description \n     
     *             0          Programs the default device setting. \n
     *         Other values   Reserved for future use. \n
     *         xWR6x43 device: \n
     *            Values specified in the xWR6x43 table \n
     */
    rlUInt8_t apllRzTrimVco;
    /**
    * @brief Reserved for future use
    */
    rlUInt8_t reserved0;
#else
    /**
     * @brief  Synth RZ trim code \n
     */
    rlUInt8_t synthRzTrim;
    /**
     * @brief  Synth ICP trim code \n
     */
    rlUInt8_t synthIcpTrim;
    /**
     * @brief  APLL RZ LPF trim code \n
     */
    rlUInt8_t apllRzTrimLpf;
    /**
     * @brief  APLL ICP trim code \n
     */
    rlUInt8_t apllIcpTrim;
    /**
    * @brief Reserved for future use
    */
    rlUInt8_t reserved0;
    /**
     * @brief  APLL RZ VCO trim code \n
     *         AWR2243 device: \n
     *           Value        Description \n     
     *             0          Programs the default device setting. \n
     *         Other values   Reserved for future use. \n
     *         xWR6x43 device: \n
     *            Values specified in the xWR6x43 table \n
     */
    rlUInt8_t apllRzTrimVco;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved[5U];
}rlRfApllSynthBwControl_t;

/*! \brief
* Advanced Chirp LUT Configuration Structure
* Load a generic chirp parameter LUT (firmware RAM of size 12kB)
*/
typedef struct rlAdvChirpLUTCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved2;
    /**
     * @brief Start address offset at which to populate the bytes of patterns. \n
     *        Address offset has to be multiple 4 bytes (word boundary). \n
     */
    rlUInt16_t lutAddressOffset;
    /**
     * @brief Number of valid bytes to write. \n
     *        Valid range: 4 to 212, must be multiple of 4. \n
     */
    rlUInt16_t numBytes;
    /**
     * @brief Byte array to load in to the Generic SW Chirp Parameter LUT. \n
     *        The size of this sub-block is fixed to total 232 bytes, hence it is recommended to
     *        group multiple chirp parameters and send in chunks. \n
     */
    rlInt8_t  calData[RL_MAX_ADV_CHIRP_LUT_CHUNK_SIZE];
} rlAdvChirpLUTCfg_t;

/*! \brief
* Advanced Chirp Dynamic LUT Address Offset Configuration Structure
* Configure LUT address offset dynamically for each chirp parameters
*/
typedef struct rlAdvChirpDynLUTAddrOffCfg
{
    /**
     * @brief  Enable mask for LUT address offset dynamic update, the address is updated for 
     *         following enabled chirp parameters. \n
     *         Bit            Definition \n
     *         b0             Enable CHIRP_PROFILE_SELECT \n
     *         b1             Enable CHIRP_FREQ_START_VAR \n
     *         b2             Enable CHIRP_FREQ_SLOPE_VAR \n
     *         b3             Enable CHIRP_IDLE_TIME_VAR \n
     *         b4             Enable CHIRP_ADC_START_TIME_VAR \n
     *         b5             Enable CHIRP_TX_EN \n
     *         b6             Enable CHIRP_BPM_VAL \n
     *         b7             Enable TX0_PHASE_SHIFTER \n
     *         b8             Enable TX1_PHASE_SHIFTER \n
     *         b9             Enable TX2_PHASE_SHIFTER \n
     *         b15:10         Reserved \n
     */
    rlUInt16_t addrMaskEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  This field provides the start address offset within the Generic SW Chirp Parameter 
     *         LUT which holds dither parameters (LUT Dither) for each chirp parameter, each 
     *         address offset is 2 bytes. \n
     *         The address will be updated only if ADDRESS_MASK_EN is SET. \n
     *         Bytes          Definition \n
     *         Bytes 1:0      LUT_ADDRESS_OFFSET for CHIRP_PROFILE_SELECT \n
     *         Bytes 3:2      LUT_ADDRESS_OFFSET for CHIRP_FREQ_START_VAR \n
     *         Bytes 5:4      LUT_ADDRESS_OFFSET for CHIRP_FREQ_SLOPE_VAR \n
     *         Bytes 7:6      LUT_ADDRESS_OFFSET for CHIRP_IDLE_TIME_VAR \n
     *         Bytes 9:8      LUT_ADDRESS_OFFSET for CHIRP_ADC_START_TIME_VAR \n
     *         Bytes 11:10    LUT_ADDRESS_OFFSET for CHIRP_TX_EN \n
     *         Bytes 13:12    LUT_ADDRESS_OFFSET for CHIRP_BPM_VAL \n
     *         Bytes 15:14    LUT_ADDRESS_OFFSET for TX0_PHASE_SHIFTER \n
     *         Bytes 17:16    LUT_ADDRESS_OFFSET for TX1_PHASE_SHIFTER \n
     *         Bytes 19:18    LUT_ADDRESS_OFFSET for TX2_PHASE_SHIFTER \n
     *         Address offset has to be multiple 4 bytes (word boundary) \n
     */
    rlUInt16_t lutAddressOffset[10U];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved3;
} rlAdvChirpDynLUTAddrOffCfg_t;

/**
*  @defgroup Sensor Sensor
*  @brief mmwave radar RF/Sensor Configuration Module
*
*  @image html mmwave_frontend.png
*
*  The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end.
*  mmWave Front End has below key blocks
*  -# Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing
*  the sequence of FMCW chirps or frames and programming the timing engine
*  -# Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it
*  defines how to configure the mmWave front end in cascade mode for Imaging Radar
*  -# Rx Analog Chain - This defines how the received signal is mixed and how different filters
*  in the chain can be configured
*  -# ADC and Digital Front End Configuration - This defines how the IF data is digitized and how
*  it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be
*  sent over LVDS/CSI2 interface to an extenal processor

*  The Sensor Control APIs needs to be called by application in below sequence
*  ## Initial/Static Configuration #
*  Application should first configure the mmWave Front end or Radar SS with below Static
*  configurations
*  - Channel Configuration - \ref rlSetChannelConfig
*  - ADC output Configuration - \ref rlSetAdcOutConfig
*  - Low power mode Configuration  - \ref rlSetLowPowerModeConfig
*
*  ## Initialization and Calibration #
*  After initial static configurations, application should initialize RF
*  and shall wait for calibration complete Asynchornous event
*  RL_RF_AE_INITCALIBSTATUS_SB
*  - \ref rlRfInit
*
*  ## FMCW chirp Configuration #
*  After RF initilization, Application can configure chirps and frame using
*  below APIs
*  - Profile Configuration - \ref rlSetProfileConfig
*  - Chirp Configuraiton - \ref rlSetChirpConfig
*  - Frame Configuration - \ref rlSetFrameConfig or rlSetAdvFrameConfig
*    Note about HW SYNC_IN pulse in hardware triggered mode
*
*    a. The SYNC_IN pulse must not arrive before the frame end boundary
*    b. If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse
*    periodicity should take care of the configured frame trigger delay and frame periodicity.
*    The external pulse should be issued only after the sum total of frame trigger delay and
*    frame periodicity. See figure below
*    @image html mmwave_hwsyncincareabout.png
*    c. The inter frame blank time should be at least 250 uS(100 uS for frame preparation and 150
*    uS for any calibration updates to hardware). Add 150 uS to inter-frame blank time for test
*    source configuration if test source is enabled.
*
*  ## Frame Trigger #
*  After All the configuration, Application can use Sensor Start API
*  to start Frame and shall wait for Frame Ready Asynchronous event
*  RL_RF_AE_FRAME_TRIGGER_RDY_SB
*  - \ref rlSensorStart
*
*  ## Below is the list of advance features in mmWave Front end #
*  ## Advance Frame #
* Legacy frame config API \ref rlSetFrameConfig supports looping of the same FMCW frame.
* In order to configure multiple FMCW frames with different chirp profiles, user needs
* to use \ref rlSetAdvFrameConfig API. Advance Frame consists of one or upto 4 Sub-Frames
* Each Sub-Frame consists of multiple bursts. Each burst consists of multiple chirps as
* shown in diagram below.\n
* To enable Advance Frame, Application needs to follow below
* sequence
*  - Profile Configuration - \ref rlSetProfileConfig
*  - Chirp Configuraiton - \ref rlSetChirpConfig
*  - Advance Frame Configuration - \ref rlSetAdvFrameConfig
*
*  @image html adv_frame_seq.png
*
*  ## Dynamic Chirp Configuration #
*  Using Legacy chirp configuration API \ref rlSetChirpConfig, chirps can't be re-configure
*  without stopping the ongoing FMCW frame using \ref rlSensorStop API. \n
*  If user needs to re-configure chirp during the frame, it needs to use Dynamic chirp
*  config APIs. Once the API is received by mmWave Front end, it would re-configure the
*  chirps for next FMCW frame. Dynamic Chirps can be defined using below APIs
*  - Dynamic Chirp Configuration - \ref rlSetDynChirpCfg
*  - Enable Dynamic Chirps - \ref rlSetDynChirpEn
*
*  Diagram below shows the Dynamic Chirp behaviour. Note that since dynamic chirps are
*  configured at run time, there is not error checks done on the input data. If input data
*  is out of range or invalid, device might misbehave.
*
*  @image html dyn_chip_seq.png
*
* ## Calibration #
* TI mmWave Front end includes built-in processor that is programmed by TI to handle RF
   calibrations and functional safety monitoring.  The RF calibrations ensure that the
   performance of the device is maintained across temperature and process corners

  -# Some of the calibrations are just temperature and process based look-up-tables, which are
     used to update the RF/Analog components
  -# Built-in temperature sensors enable the device to monitor the temperature every few seconds
     and update the relevant components accordingly
*
*
* ## API Programming Sequence #
*
* ## Single Device mode
*
* -# Power up the device
* -# Wait for AWR_AE_MSSPOWERUPDONE_SB
* -# Wait for AWR_AE_MSS_BOOTERRORSTATUS_SB if flash is not connected (Boot over SPI)
* -# AWR_DEV_CONFIGURATION_SET_SB
* -# AWR_DEV_RFPOWERUP_SB
* -# Wait for AWR_AE_RFPOWERUPDONE_SB
* -# AWR_RF_STATIC_CONF_SET_MSG
*    -  AWR_RF_DEVICE_CFG_SB
*    -  AWR_CHAN_CONF_SET_SB
*    -  AWR_ADCOUT_CONF_SET_SB
*    -  AWR_RF_LDO_BYPASS_SB with RFLDOBYPASS_EN set to 1 if RF supply is 1.0 V
*    -  AWR_LOWPOWERMODE_CONF_SET_SB
*    -  AWR_DYNAMICPOWERSAVE_CONF_SET_SB
*    -  AWR_CAL_MON_FREQUENCY_TX_POWER_LIMITS_SB
*    -  AWR_RF_RADAR_MISC_CTL_SB if per chirp phase shifter and Advance chirp configuration
*       needs to be enabled.
*    -  AWR_APLL_SYNTH_BW_CONTROL_SB
* -# Data path configurations
*    -  AWR_DEV_RX_DATA_FORMAT_CONF_SET_SB
*    -  AWR_DEV_RX_DATA_PATH_CONF_SET_SB
*    -  AWR_DEV_RX_DATA_PATH_LANE_EN_SB
*    -  AWR_DEV_RX_DATA_PATH_CLK_SET_SB
*    -  AWR_HIGHSPEEDINTFCLK_CONF_SET_SB
*    -  AWR_DEV_LVDS_CFG_SET_SB / AWR_DEV_CSI2_CFG_SET_SB
* -# AWR_RF_INIT_MSG
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX0), keep CAL_APPLY = 0
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX1), keep CAL_APPLY = 0
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX2), keep CAL_APPLY = 1
*    -  AWR_CAL_DATA_RESTORE_SB (To restore factory calibration data to avoid on field
*       RF interference during calibration)
*    -  Wait for AWR_AE_RF_INITCALIBSTATUS_SB
*    -  AWR_RF_INIT_CALIBRATION_CONF_SB (Enable only required calibration to run)
*    -  AWR_RFINIT_SB: This triggers very basic calibrations and RF initializations
*    -  Wait for AWR_AE_RF_INITCALIBSTATUS_SB
* -# AWR_RF_DYNAMIC_CONF_SET_MSG
*    -  AWR_PROG_FILT_COEFF_RAM_SET_SB
*    -  AWR_PROG_FILT_CONF_SET_SB
*    -  AWR_PROFILE_CONF_SET_SB
*    -  Chirp configuration API
*    -  AWR_CHIRP_CONF_SET_SB or
*    -  AWR_ADVANCE_CHIRP_CONF_SB and
*    -  AWR_ADVANCE_CHIRP_GENERIC_LUT_LOAD_SB
*    -  AWR_LOOPBACK_BURST_CONF_SET_SB (if using loopback burst in advance frame config API)
*    -  AWR_FRAME_CONF_SET_SB or AWR_ADVANCED_FRAME_CONF_SB with SW
*       or HW triggered mode and AWR_DEV_FRAME_CONFIG_APPLY_MSG.
*    -  AWR_CALIB_MON_TIME_UNIT_CONF_SB with CALIB_MON_TIME_UNIT value set
*       to a value such that the total frame idle time across multiple CALIB_MON_TIME_UNITs 
*       is sufficient for all calibrations and monitoring. See Section 12 for details on
*       calibration and monitoring durations. If any error AWR_CAL_MON_TIMING_FAIL_REPORT_AE_SB 
*       AE will be generated when frame is triggered. The calibrations
*       and monitors will not run properly if this error is generated.
*    -  Set NUM_OF_CASCADED_DEV to 1, DEVICE_ID to 0 and Set MONITORING_MODE = 0 
*       (MONITORING_MODE 1 is recommended only in cascade mode) in
*       AWR_CALIB_MON_TIME_UNIT_CONF_SB API
*    -  AWR_RUN_TIME_CALIBRATION_CONF_AND_TRIGGER_SB (set all ONE_TIME_CALIB_ENABLE_MASK and 
*       set ENABLE_CAL_REPORT = 1)
*    -  Wait for AWR_RUN_TIME_CALIBRATION_SUMMARY_REPORT_AE_SB
*    -  AWR_RUN_TIME_CALIBRATION_CONF_AND_TRIGGER_SB (set all RUN_TIME_CALIB_ENABLE_MASK and 
*       set ENABLE_CAL_REPORT = 0 to avoid receiving periodic async events)
*    -  AWR_DEV_FRAME_CONFIG_APPLY_SB or AWR_DEV_ADV_FRAME_CONFIG_APPLY_SB
* -# MONITOR CONFIGURATIONS
*    -  AWR_MONITOR_RF_DIG_LATENTFAULT_CONF_SB : Wait for 
&       AWR_MONITOR_RF_DIG_LATENTFAULT_REPORT_AE_SB AE. This API should not be issue when
*       frames are running.
*    -  AWR_MSS_LATENTFAULT_TEST_CONF_SB :Wait for AWR_AE_MSS_LATENTFAULT_TESTREPORT_SB AE.
*    -  AWR_MSS_PERIODICTESTS_CONF_SB : Enable periodic digital monitors, the monitor
*       starts immediately after enabling this API.
*    -  AWR_MONITOR_RF_DIG_PERIODIC_CONF_SB : Enable periodic digital monitors
*    -  AWR_MONITOR_ANALOG_ENABLES_CONF_SB : Enable periodic analog monitors,
*       The corresponding monitoring configuration APIs should be issued after issuing
*       this API. Refer latest release note for all supported monitors.
* -# AWR_RF_FRAME_TRIG_MSG for frame start
*    -  AWR_FRAMESTARTSTOP_CONF_SB in Start mode (1): after this, frames get transmitted,
*       wait for AWR_AE_RF_FRAME_TRIGGER_RDY_SB AE.
* -# AWR_RF_FRAME_TRIG_MSG for frame stop
*    -  AWR_FRAMESTARTSTOP_CONF_SB in Stop mode (0): after this, frames are stopped.
*       Wait for AWR_FRAME_END_AE_SB AE. The AWR_RF_FRAME_TRIG_MSG may
*       be issued multiple times for multiple sets of frames. Refer AWR_FRAMESTARTSTOP_CONF_SB 
*       for more frame stop options.
*
*
* ## Cascade Device mode
*
<table>
<caption id="ChirpModeCascadeSeq">Chirping mode (cascaded)</caption>
<tr><th>S No<th>Master Device Sequence<th>Slave Device Sequence
<tr><td>1<td>Power up master device<td>
<tr><td>2<td>Wait for AWR_AE_DEV_MSSPOWERUPDONE_SB<td>
<tr><td>3<td>AWR_DEV_RFPOWERUP_SB<td>
<tr><td>4<td>Wait for AWR_AE_DEV_RFPOWERUPDONE_SB<td>
<tr><td>5<td>AWR_CHAN_CONF_SET_SB with CASCADING_CFG = 0x0001. The reference clock for slave 
device is enabled by default<td>
<tr><td>6<td><td>Power on slave device
<tr><td>7<td><td>Wait for AWR_AE_DEV_MSSPOWERUPDONE_SB
<tr><td>8<td><td>AWR_DEV_RFPOWERUP_SB
<tr><td>9<td><td>Wait for AWR_AE_DEV_RFPOWERUPDONE_SB
<tr><td>10<td><td>AWR_CHAN_CONF_SET_SB with CASCADING_CFG = 0x0002 and disable OSC CLOCK OUT.
<tr><td>11<td>Follow all AWR_RF_STATIC_CONF_SET_MSG APIs sequence as instructed in single chip 
mode, please refer application Care Abouts above if any deviation from single chip<td>Follow all 
AWR_RF_STATIC_CONF_SET_MSG APIs sequence as instructed in single chip mode, please refer 
application Care Abouts above if any deviation from single chip
<tr><td>12<td>Follow all Data path configurations APIs sequence as instructed in single chip
mode<td>Follow all Data path configurations APIs sequence as instructed in single chip mode
<tr><td>13<td>Follow all AWR_RF_INIT_MSG APIs sequence as instructed in single chip mode<td>
Follow all AWR_RF_INIT_MSG APIs sequence as instructed in single chip mode
<tr><td>14<td>Follow all AWR_RF_DYNAMIC_CONF_SET_MSG APIs sequence as instructed in single chip 
mode, please refer application Care Abouts above if any deviation from single chip<td>Follow all 
AWR_RF_DYNAMIC_CONF_SET_MSG APIs sequence as instructed in single chip mode, please refer 
application Care Abouts above if any deviation from single chip
<tr><td>15<td>Follow all MONITOR CONFIGURATIONS APIs sequence as instructed in single chip
mode, please refer application Care Abouts above if any deviation from single chip<td>Follow 
all MONITOR CONFIGURATIONS APIs sequence as instructed in single chip mode, please refer 
application Care Abouts above if any deviation from single chip
<tr><td>16<td><td>AWR_FRAMESTARTSOP_CONF_SB with STARTSTOP_CMD = 0x0001
<tr><td>17<td><td>Wait for AWR_AE_RF_FRAME_TRIGGER_RDY_SB
<tr><td>18<td>AWR_FRAMESTARTSOP_CONF_SB with STARTSTOP_CMD = 0x0001<td>
<tr><td>19<td>Wait for AWR_AE_RF_FRAME_TRIGGER_RDY_SB<td>
<tr><td>20<td>Trigger AWR_MONITOR_TYPE_TRIG_CONF_SB API for type 0, 1 and 2 monitors and follow 
instructions mentioned in this API section<td>Trigger AWR_MONITOR_TYPE_TRIG_CONF_SB API for 
type 0, 1 and 2 monitors and follow instructions mentioned in this API section
<tr><td>21<td><td>AWR_FRAMESTARTSOP_CONF_SB with STARTSTOP_CMD = 0x0000
<tr><td>22<td><td>Wait for AWR_FRAME_END_AE_SB AE
<tr><td>23<td>AWR_FRAMESTARTSOP_CONF_SB with STARTSTOP_CMD = 0x0000<td>
<tr><td>24<td>Wait for AWR_FRAME_END_AE_SB AE<td>
</table>
*
* ## Application care abouts in Cascade mode #
* When using cascaded devices, the reference clock is provided by master to slave. So unless
  master is powered-up and clock is available from master to slave, the slave device cannot be
  powered up.
  
* Following instructions and sequence needs to be followed in cascade mode (Master and Slave
  mode configured in CASCADING_CFG field in \ref rlSetChannelConfig API):
  -# Disable OSC clock out (OSCCLKOUT_DIS = 1) for slaves in \ref rlSetChannelConfig API
  -# Write INTER_BURST_POWER_SAVE_DIS = 0 (Enable inter-burst power save) in \ref rlRfSetDeviceCfg 
     (default setting)
  -# Write WDT_ENABLE = 0 (Disable WDT) in \ref rlRfSetDeviceCfg (default setting)
  -# Set MONITORING_MODE = 1 (API based monitor trigger. The automated monitoring trigger is 
     also supported in cascade mode, not used in this sequence)
  -# Set NUM_OF_CASCADED_DEV to 1 and DEVICE_ID to 0 in \ref rlRfSetCalMonTimeUnitConfig (Not 
     recommended to set other values for proper functionality in MONITORING_MODE = 1)
  -# Clear PERIODIC_CALIB_ENABLE_MASK and set CALIBRATION_PERIODICITY to 0 to avoid run time
     calibration (Automated run time calibration is not recommended in cascade mode)
  -# When stopping the frames in master it is recommended to stop Slaves first and wait of frame 
     stop AE then stop the master.
  -# Follow API based monitor trigger notes in \ref rlMonTypeTrigConfig API section
  -# Set TRIGGER_SELECT = 1 in master device and TRIGGER_SELECT = 2 in slave device in 
     \ref rlSetFrameConfig or \ref rlSetAdvFrameConfig API.
*
*
*
* ## Continuous streaming mode (in single device case)
*
* -# Power up the device
* -# Wait for AWR_AE_MSSPOWERUPDONE_SB
* -# Wait for AWR_AE_MSS_BOOTERRORSTATUS_SB if flash is not connected (Boot over SPI)
* -# AWR_DEV_CONFIGURATION_SET_SB
* -# AWR_DEV_RFPOWERUP_SB
* -# Wait for AWR_AE_RFPOWERUPDONE_SB
* -# AWR_RF_STATIC_CONF_SET_MSG
*    -  AWR_RF_DEVICE_CFG_SB
*    -  AWR_CHAN_CONF_SET_SB
*    -  AWR_ADCOUT_CONF_SET_SB
*    -  AWR_RF_LDO_BYPASS_SB with RFLDOBYPASS_EN set to 1 if RF supply is 1.0 V
*    -  AWR_LOWPOWERMODE_CONF_SET_SB
*    -  AWR_DYNAMICPOWERSAVE_CONF_SET_SB
*    -  AWR_CAL_MON_FREQUENCY_TX_POWER_LIMITS_SB
*    -  AWR_RF_RADAR_MISC_CTL_SB if per chirp phase shifter and Advance chirp configuration
*       needs to be enabled.
*    -  AWR_APLL_SYNTH_BW_CONTROL_SB
* -# Data path configurations
*    -  AWR_DEV_RX_DATA_FORMAT_CONF_SET_SB
*    -  AWR_DEV_RX_DATA_PATH_CONF_SET_SB
*    -  AWR_DEV_RX_DATA_PATH_LANE_EN_SB
*    -  AWR_DEV_RX_DATA_PATH_CLK_SET_SB
*    -  AWR_HIGHSPEEDINTFCLK_CONF_SET_SB
*    -  AWR_DEV_LVDS_CFG_SET_SB / AWR_DEV_CSI2_CFG_SET_SB
* -# AWR_RF_INIT_MSG
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX0), keep CAL_APPLY = 0
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX1), keep CAL_APPLY = 0
*    -  AWR_PHASE_SHIFTER_CAL_DATA_RESTORE_SB (To restore factory calibration
*       data for TX2), keep CAL_APPLY = 1
*    -  AWR_CAL_DATA_RESTORE_SB (To restore factory calibration data to avoid on field
*       RF interference during calibration)
*    -  Wait for AWR_AE_RF_INITCALIBSTATUS_SB
*    -  AWR_RF_INIT_CALIBRATION_CONF_SB (Enable only required calibration to run)
*    -  AWR_RFINIT_SB: This triggers very basic calibrations and RF initializations
*    -  Wait for AWR_AE_RF_INITCALIBSTATUS_SB
* -# AWR_RF_DYNAMIC_CONF_SET_MSG
*    -  AWR_PROG_FILT_COEFF_RAM_SET_SB
*    -  AWR_PROG_FILT_CONF_SET_SB
* -# AWR_CONT_STREAMING_MODE_EN_SB to start the trigger
*    -  AWR_CONT_STREAMING_MODE_CONF_SET_SB
*    -  AWR_DEV_RX_CONTSTREAMING_MODE_CONF_SET_SB
*    -  AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0001
*       to start continuous streaming
* -# AWR_CONT_STREAMING_MODE_EN_SB to stop the trigger
     -  AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0000
        to stop continuous streaming
*
*
* ## Continuous streaming (CW) mode (in cascaded device case)
*
<table>
<caption id="ContinousModeCascadeSeq">Continuous streaming (CW) mode (cascaded)</caption>
<tr><th>S No<th>Master Device Sequence<th>Slave Device Sequence
<tr><td>1<td>Power up master device<td>
<tr><td>2<td>Wait for AWR_AE_DEV_MSSPOWERUPDONE_SB<td>
<tr><td>3<td>AWR_DEV_RFPOWERUP_SB<td>
<tr><td>4<td>Wait for AWR_AE_DEV_RFPOWERUPDONE_SB<td>
<tr><td>5<td>AWR_CHAN_CONF_SET_SB with CASCADING_CFG = 0x0001. The reference clock for slave 
device is enabled by default<td>
<tr><td>6<td><td>Power on slave device
<tr><td>7<td><td>Wait for AWR_AE_DEV_MSSPOWERUPDONE_SB
<tr><td>8<td><td>AWR_DEV_RFPOWERUP_SB
<tr><td>9<td><td>Wait for AWR_AE_DEV_RFPOWERUPDONE_SB
<tr><td>10<td><td>AWR_CHAN_CONF_SET_SB with CASCADING_CFG = 0x0002 and disable OSC CLOCK OUT.
<tr><td>11<td>Follow all AWR_RF_STATIC_CONF_SET_MSG APIs sequence as instructed in single chip 
mode, please refer application Care Abouts above if any deviation from single chip<td>Follow all 
AWR_RF_STATIC_CONF_SET_MSG APIs sequence as instructed in single chip mode, please refer 
application Care Abouts above if any deviation from single chip
<tr><td>12<td>Follow all Data path configurations APIs sequence as instructed in single chip
mode<td>Follow all Data path configurations APIs sequence as instructed in single chip mode
<tr><td>13<td>Follow all AWR_RF_INIT_MSG APIs sequence as instructed in single chip mode<td>
Follow all AWR_RF_INIT_MSG APIs sequence as instructed in single chip mode
<tr><td>14<td>Follow all AWR_RF_DYNAMIC_CONF_SET_MSG APIs sequence as instructed in single chip 
mode, please refer application Care Abouts above if any deviation from single chip<td>Follow all 
AWR_RF_DYNAMIC_CONF_SET_MSG APIs sequence as instructed in single chip mode, please refer 
application Care Abouts above if any deviation from single chip
<tr><td>15<td>AWR_CONT_STREAMING_MODE_CONF_SET_SB<td>
<tr><td>16<td>AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0001 to start continuous 
streaming<td>
<tr><td>17<td><td>AWR_CONT_STREAMING_MODE_CONF_SET_SB with the same RF frequency configuration as 
in master device
<tr><td>18<td><td>AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0001 to start 
continuous streaming
<tr><td>19<td><td>AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0000 to stop 
continuous streaming
<tr><td>20<td>AWR_CONT_STREAMING_MODE_EN_SB with CONT_STREAMING_EN = 0x0000 to stop continuous 
streaming<td>
<tr><td>21<td>Repeat steps 6-20 for a different CW mode configuration<td>
</table>
*
* Below is the list of calibrations and corresponding duration in microseconds \n
* Boot Time Calibration
<table>
<caption id="bootTimeCalibration">Calibration Duration</caption>
<tr><th>Calibration                      <th>Duration(us)
<tr><td>APLL<td>500
<tr><td>Synth VCO<td>2500
<tr><td>LO DIST<td>1500
<tr><td>ADC DC <td>600
<tr><td>HPF cutoff <td>3500
<tr><td>LPF cut off <td>200
<tr><td>Peak detector<td>7000
<tr><td>TX power (for each TX)<td>2000
<tr><td>RX gain <td>1500
<tr><td>TX phase (for each TX)<td>12000
<tr><td>RX IQMM<td>42000
</table>

<table>
<caption id="bootTimeCalibration6243">Calibration Duration for xWR6243 device</caption>
<tr><th>Calibration                      <th>Duration(us)
<tr><td>APLL<td>500
<tr><td>Synth VCO (VCO1, VCO2)<td>2500
<tr><td>Synth VCO (VCO1, VCO2, VCO3)<td>3750
<tr><td>LO DIST<td>15
<tr><td>ADC DC <td>600
<tr><td>HPF cutoff <td>3500
<tr><td>LPF cut off <td>200
<tr><td>Peak detector<td>8000
<tr><td>TX power (for each TX)<td>3000
<tr><td>RX gain <td>1500
<tr><td>TX phase (for each TX)<td>12000
<tr><td>RX IQMM<td>42500
</table>

* Run Time Calibration
  The Calibration Total duration is consist of two components,
  -# Critical calibration chirp time, this is fixed to 145 us. Each calibration can have multiple 
     critical chirps to complete the task, the total critical time captured in below table. 
     The critical tasks are done in chunks of 145 us, refer \ref interBurstTime for more info.
  -# Non critical setup and processing time, this is a variable component specific to each 
     calibration, the total calibration duration captured in below table = total critical time + 
     non critical time.
  Note that the User has to ensure the total idle time in one CAL_MON_TIME_UNIT is sufficient to 
  fit the enabled calibrations.
<table>
<caption id="runTimeCalibration">Calibration Duration</caption>
<tr><th>Calibration                <th>Total Duration(us)<th>Total Critical Time(us)
<tr><td>APLL<td>150<td>145
<tr><td>Synth VCO<td>300<td>290
<tr><td>LO DIST<td>30<td>0
<tr><td>Peak detector<td>600<td>580
<tr><td>TX power CLPC (for each TX and for 1 profile)<td>800<td>580
<tr><td>TX power OLPC (In case CLPC is disabled)<td>30<td>0
<tr><td>RX gain <td>30<td>0
<tr><td>Application of calibration to hardware (This needs to be included always) <td>50<td>50
</table>

<table>
<caption id="runTimeCalibration6243">Calibration Duration for xWR6243 device</caption>
<tr><th>Calibration                <th>Total Duration(us)<th>Total Critical Time(us)
<tr><td>APLL<td>150<td>145
<tr><td>Synth VCO (VCO1, VCO2)<td>350<td>290
<tr><td>Synth VCO (VCO1, VCO2, VCO3)<td>525<td>435
<tr><td>LO DIST<td>30<td>0
<tr><td>Peak detector<td>600<td>580
<tr><td>TX power CLPC (for each TX and for 1 profile)<td>800<td>580
<tr><td>TX power OLPC (In case CLPC is disabled)<td>30<td>0
<tr><td>RX gain <td>30<td>0
<tr><td>Application of calibration to hardware (This needs to be included always) <td>50<td>50
</table>
*
* ## Chirp, Burst and Frame timings #
* AWR2243/xWR6243 device minimum chirp cycle time, inter-burst time, inter sub-frame/frame
  time requirements are documented in this section.

* Chirp Cycle Time
<table>
<caption id="chirpCycleTime">Minimum chirp cycle time</caption>
<tr><th>Use case              <th>Min Chirp cycle time(us)<th>Description
<tr><td>Typical chirps<td>13<td>The normal chirps used in a burst or a frame using legacy chirp 
configuration API
<tr><td>Advance chirps<td>25<td>The advance chirps used in a burst or a frame using advanced chirp 
configuration API
<tr><td>Chirps in Continuous framing mode<td>20<td>A single advance chirp used in a burst using 
either normal legacy chirp or advanced chirp configuration API. Continuous framing mode is a mode 
in which a single chirp is programmed in a burst using advanced frame configuration API. In this 
mode it is recommended to set idle time of chirp minimum 10us to save Inter chirp power save 
override time (Refer below table)
</table>

* Minimum Inter Burst Time
<table>
<caption id="interBurstTime">Minimum Inter Burst Time</caption>
<tr><th>Min inter burst time     <th>Time(us)<th>Description
<tr><td>Typical inter burst time<td>55<td>The minimum inter burst idle time required in normal 
bursts with legacy chirps configured in a advanced frame configuration API with inter burst power 
save disabled.
<tr><td>Inter burst power save time<td>55<td>Add inter burst power save time to minimum inter burst
 time if it is enabled. By default inter-burst power save is enabled, it can be disabled (Only in 
 single chip mode) using \ref rlRfSetDeviceCfg API
<tr><td>Inter chirp power save override time (power save disable)<td>15<td>Add inter chirp power 
save override time to minimum inter burst time if chirp idle time < 10us in a burst or can be 
controlled using \ref rlRfDynamicPowerSave API
<tr><td>Advance chirp configuration time<td>45<td>Add advance chirp configuration time to minimum
inter burst time if advance chirp configuration is enabled in \ref rlRfSetMiscConfig API. Not 
applicable for Continuous framing mode (Refer below).
<tr><td>Advance chirp configuration time (Continuous framing mode)<td>30<td>Add Continuous framing 
mode advance chirp configuration time to minimum inter burst time if advance chirp configuration 
is enabled in \ref rlRfSetMiscConfig API. Continuous framing mode is a mode in which a 
single chirp is programmed in a burst using advanced frame configuration API.
<tr><td>Normal chirps (Continuous framing mode)<td>10<td>Add Continuous framing mode normal chirp 
configuration time to minimum inter burst time. Continuous framing mode is a mode in which a 
single chirp is programmed in a burst using advanced frame configuration API.
<tr><td>Calibration or Monitoring chirp time<td>145<td>Add calibration or Monitoring chirp time to
minimum inter burst time if calibration or monitors intended to be run in inter burst idle time. 
The calibration and monitoring chirps can run only in inter sub-frame or inter-frame interval if 
this time is not allocated in inter-burst time. Add calibration or Monitoring duration to minimum 
inter burst or sub-frame/frame time.
</table>

* Minimum Inter Sub-frame or Frame Time
<table>
<caption id="interSubFrameTime">Minimum Inter Sub-frame or Frame Time</caption>
<tr><th>Min inter subframe/frame time<th>Time(us)<th>Description
<tr><td>Typical inter subframe/frame time<td>300<td>The minimum inter sub-frame/frame idle time
required in normal sub-frames with legacy chirps configured in a advanced frame configuration API
or in a legacy frame config API. This time includes time required for minimum inter-burst idle 
time, inter burst power save, inter chirp power save override and single calibration/monitoring
chirp time.
<tr><td>Advance chirp configuration time<td>45<td>Add advance chirp configuration time to minimum
inter sub-frame/frame time if advance chirp configuration is enabled in \ref rlRfSetMiscConfig API
<tr><td>Calibration or Monitoring duration<td>Table 12.4 and Table 12.8<td>Add 
calibration or Monitoring duration to minimum inter sub-frame/frame time based on Table 12.4 and 
Table 12.8
<tr><td>Loop-back burst configuration time<td>300<td>Add Loop-back burst configuration time to
minimum inter sub-frame time for loop back sub-frames if it is enabled in advance frame config API
<tr><td>Dynamic legacy chirp configuration time (for 16 chirps)<td>20 for 16 chirps + 500<td>Add 
dynamic legacy chirp configuration time to minimum inter frame time if dynamic chirp/phase-shifter 
APIs are issued in runtime.
<tr><td>Dynamic advance chirp configuration time (without LUT)<td>500<td>Add dynamic advance chirp 
configuration time to minimum inter frame time if dynamic advance chirp API is issued in runtime. 
The dynamic update of advance chirp generic LUT is done immediately when the API is received at 
BSS and there is no impact to inter frame time, however user has to take care of timing of the LUT 
update as it should not corrupt the ongoing chirp configuration.
<tr><td>Dynamic profile configuration time (for 1 profile)<td>1200<td>Add dynamic profile 
configuration time to minimum inter frame time if dynamic profile API is issued in runtime.
<tr><td>Test source config time<td>170<td>Add test source configuration time to minimum inter 
sub-frame time if test source API is issued.
</table>

* Typical APLL and Synth BW settings
<table>
<caption id="ApllSynthBwSettings6243">Typical APLL and Synth BW settings for xWR6x43</caption>
<tr><th>Synth ICP<th>Synth Rtrim<th>APLL ICP<th>APLL Rtrim LPF
    <th>APLL Rtrim VCO<th>VCO1_BW/VCO3_BW<th>VCO2_BW<th>APLL_BW<th>Emission Improv
    <th>1M PN Degrad at 60G<th>100K PN Improv at 60G<th>Max Slope (MHz/us)
<tr><td>1<td>8<td>0x26<td>0x9<td>8<td>1.5M<td>1.5M<td>150K<td>2 dB<td>2 dB<td>0 dB<td>250
<tr><td>3<td>8<td>0x26<td>0x9<td>8<td>0.75M<td>0.75M<td>150K<td>2 dB<td>2 dB<td>0 dB<td>125
<tr><td>1<td>8<td>0x3F<td>0x9<td>8<td>1.5M<td>1.5M<td>300K<td>2 dB<td>4 dB<td>5 dB<td>250
<tr><td>1<td>8<td>0x26<td>0x9<td>5<td>1.5M<td>1.5M<td>150K<td>8 dB<td>1.5 dB<td>0 dB<td>250
<tr><td>3<td>8<td>0x26<td>0x9<td>5<td>0.75M<td>0.75M<td>150K<td>8 dB<td>1.5 dB<td>0 dB<td>125
<tr><td>1<td>8<td>0x3F<td>0x9<td>5<td>1.5M<td>1.5M<td>300K<td>8 dB<td>3.5 dB<td>5 dB<td>250
<tr><td>1<td>8<td>0x26<td>0x9<td>6<td>1.5M<td>1.5M<td>150K<td>5 dB<td>1 dB<td>0 dB<td>250
<tr><td>3<td>8<td>0x26<td>0x9<td>6<td>0.75M<td>0.75M<td>150K<td>5 dB<td>1 dB<td>0 dB<td>125
<tr><td>1<td>8<td>0x3F<td>0x9<td>6<td>1.5M<td>1.5M<td>300K<td>5 dB<td>3 dB<td>5 dB<td>250
<tr><td>1<td>8<td>0x26<td>0x9<td>18<td>1.5M<td>1.5M<td>150K<td>0 dB<td>0 dB<td>0 dB<td>250
<tr><td>3<td>8<td>0x26<td>0x9<td>18<td>0.75M<td>0.75M<td>150K<td>0 dB<td>0 dB<td>0 dB<td>125
<tr><td>1<td>8<td>0x3F<td>0x9<td>18<td>1.5M<td>1.5M<td>300K<td>0 dB<td>2 dB<td>5 dB<td>250
</table>

<table>
<caption id="ApllSynthBwSettings2243">Typical APLL and Synth BW settings for AWR2243</caption>
<tr><th>SYNTH_ICP_TRIM<th>SYNTH_RZ_TRIM<th>APLL_ICP_TRIM<th>APLL_RZ_TRIM<th>VCO1_BW<th>VCO2_BW
    <th>APLL_BW<th>Description<th>Max VCO Slope (MHz/us)
<tr><td>1<td>8<td>0x26<td>0x9<td>750K<td>1.5M<td>150K<td>Default settings (+/-0.2% Ferror at 2us 
ADC start)<td>266
<tr><td>3<td>8<td>0x26<td>0x9<td>375K<td>750K<td>150K<td>Optimum for 76-77GHz VCO1 (1M, 10M PN)
<td>100
<tr><td>0<td>8<td>0x26<td>0x9<td>1.3M<td>2.6M<td>150K<td>Synth High BW (+/-0.2% Ferror at 1us ADC 
start)<td>266
<tr><td>3<td>8<td>0x3F<td>0x9<td>375K<td>1.5M<td>300K<td>Optimum 100K PN<td>100
</table>

* Programmable filter DFE sampling rate and max number of taps
<table>
<caption id="ProgFiltSettings">Programmable filter DFE sampling rate and max num of taps</caption>
<tr><th>DFE sampling rate Fs(Msps)<th>Max no of taps in Real Mode<th>Max no of taps in Complex Mode
<tr><td>>=25<td>42<td>NA
<tr><td>>=12.5, <25<td>42<td>21
<tr><td>>=6.25, <12.5<td>63<td>45
<tr><td>Else<td>63<td>63
</table>

*    Related Files
*   - rl_sensor.c
*  @addtogroup Sensor
*  @{
*/

/******************************************************************************
 * FUNCTION DECLARATIONS
 ******************************************************************************
 */
 
/* RF/Sensor Configuration Functions */

/*Rx and Tx Channel Configuration */
MMWL_EXPORT rlReturnVal_t rlSetChannelConfig(rlUInt8_t deviceMap, rlChanCfg_t* data);

/*ADC Out Configuration */
MMWL_EXPORT rlReturnVal_t rlSetAdcOutConfig(rlUInt8_t deviceMap, rlAdcOutCfg_t* data);

/*Low Power Mode */
MMWL_EXPORT rlReturnVal_t rlSetLowPowerModeConfig(rlUInt8_t deviceMap,
                                                  rlLowPowerModeCfg_t* data);

/*RF Init */
MMWL_EXPORT rlReturnVal_t rlRfInit(rlUInt8_t deviceMap);

/*Profile Configuration */
MMWL_EXPORT rlReturnVal_t rlGetProfileConfig(rlUInt8_t deviceMap,
                                             rlUInt16_t profileId,
                                             rlProfileCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetProfileConfig(rlUInt8_t deviceMap,
                                             rlUInt16_t cnt,
                                             rlProfileCfg_t* data);

/*Chirp Configuration */
MMWL_EXPORT rlReturnVal_t rlGetChirpConfig(rlUInt8_t deviceMap, rlUInt16_t chirpStartIdx,
                                           rlUInt16_t chirpEndIdx, rlChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetChirpConfig(rlUInt8_t deviceMap,
                                           rlUInt16_t cnt,
                                           rlChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetMultiChirpCfg(rlUInt8_t deviceMap, rlUInt16_t cnt,
                                             rlChirpCfg_t **data);

/*Frame Configuration */
MMWL_EXPORT rlReturnVal_t rlGetFrameConfig(rlUInt8_t deviceMap, rlFrameCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetFrameConfig(rlUInt8_t deviceMap, rlFrameCfg_t* data);

/*Sensor Trigger */
MMWL_EXPORT rlReturnVal_t rlSensorStart(rlUInt8_t deviceMap);
MMWL_EXPORT rlReturnVal_t rlSensorStop(rlUInt8_t deviceMap);
MMWL_EXPORT rlReturnVal_t rlFrameStartStop(rlUInt8_t deviceMap, rlFrameTrigger_t* data);

/*Advance Frame Configuration */
MMWL_EXPORT rlReturnVal_t rlGetAdvFrameConfig(rlUInt8_t deviceMap,
                                              rlAdvFrameCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetAdvFrameConfig(rlUInt8_t deviceMap,
                                              rlAdvFrameCfg_t* data);

/*Continous mode Configuration */
MMWL_EXPORT rlReturnVal_t rlSetContModeConfig(rlUInt8_t deviceMap,
                                              rlContModeCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlEnableContMode(rlUInt8_t deviceMap, rlContModeEn_t* data);

/*BPM Configuration */
MMWL_EXPORT rlReturnVal_t rlSetBpmCommonConfig(rlUInt8_t deviceMap,
                                               rlBpmCommonCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetBpmChirpConfig(rlUInt8_t deviceMap,
                                              rlBpmChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetMultiBpmChirpConfig(rlUInt8_t deviceMap,
                                                   rlUInt16_t cnt, rlBpmChirpCfg_t** data);

/*Test Source Configuration */
MMWL_EXPORT rlReturnVal_t rlSetTestSourceConfig(rlUInt8_t deviceMap,
                                                rlTestSource_t* data);
MMWL_EXPORT rlReturnVal_t rlTestSourceEnable(rlUInt8_t deviceMap,
                                             rlTestSourceEnable_t* data);

/*Get RF Characterization Time and Temperature information */
MMWL_EXPORT rlReturnVal_t rlRfGetTemperatureReport(rlUInt8_t deviceMap,
                                                   rlRfTempData_t* data);

/*Get RF Digital Front End Statistics */
MMWL_EXPORT rlReturnVal_t rlRfDfeRxStatisticsReport(rlUInt8_t deviceMap,
                                                    rlDfeStatReport_t* data);

/*Dynamic Power save Configuration */
MMWL_EXPORT rlReturnVal_t rlRfDynamicPowerSave(rlUInt8_t deviceMap,
                                               rlDynPwrSave_t* data);

/*RadarSS Device configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetDeviceCfg(rlUInt8_t deviceMap, rlRfDevCfg_t* data);

/*GPADC Read(From external Input) configuration */
MMWL_EXPORT rlReturnVal_t rlSetGpAdcConfig(rlUInt8_t deviceMap, rlGpAdcCfg_t* data);

/* LDO bypass Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetLdoBypassConfig(rlUInt8_t deviceMap,
                                                 rlRfLdoBypassCfg_t* data);

/*Per Chirp Phase Shifter Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPhaseShiftConfig(rlUInt8_t deviceMap, rlUInt16_t cnt,
                                                  rlRfPhaseShiftCfg_t* data);

/* PA loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPALoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfPALoopbackCfg_t* data);

/* Phase Shift Loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPSLoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfPSLoopbackCfg_t* data);

/* IF loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetIFLoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfIFLoopbackCfg_t* data);

/* Programmable Filter RAM coefficients */
MMWL_EXPORT rlReturnVal_t rlRfSetProgFiltCoeffRam(rlUInt8_t deviceMap,
                                                  rlRfProgFiltCoeff_t* data);

/* programmable Filter Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetProgFiltConfig(rlUInt8_t deviceMap,
                                                rlRfProgFiltConf_t* data);

/*Radar Misc Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetMiscConfig(rlUInt8_t deviceMap,
                                            rlRfMiscConf_t* data);

/*Calibration/monitoring Time Unit Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetCalMonTimeUnitConfig(rlUInt8_t deviceMap,
                                                      rlRfCalMonTimeUntConf_t* data);

/*Calibration/monitoring Freq Limit Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetCalMonFreqLimitConfig(rlUInt8_t deviceMap,
                                                       rlRfCalMonFreqLimitConf_t* data);

/*Init time calibration Configuration */
MMWL_EXPORT rlReturnVal_t rlRfInitCalibConfig(rlUInt8_t deviceMap,
                                              rlRfInitCalConf_t* data);

/*Run time calibration Configuration */
MMWL_EXPORT rlReturnVal_t rlRfRunTimeCalibConfig(rlUInt8_t deviceMap,
                                                 rlRunTimeCalibConf_t* data);

/*Rx Gain Look up Table (LUT) Update APIs */
MMWL_EXPORT rlReturnVal_t rlRxGainTempLutSet(rlUInt8_t deviceMap,
                                             rlRxGainTempLutData_t *data);
MMWL_EXPORT rlReturnVal_t rlRxGainTempLutGet(rlUInt8_t deviceMap,
                                             rlRxGainTempLutReadReq_t *inData,
                                             rlRxGainTempLutData_t *outData);

/*Tx Gain Look up Table (LUT) Update APIs */
MMWL_EXPORT rlReturnVal_t rlTxGainTempLutSet(rlUInt8_t deviceMap,
                                             rlTxGainTempLutData_t *data);
MMWL_EXPORT rlReturnVal_t rlTxGainTempLutGet(rlUInt8_t deviceMap,
                                             rlTxGainTempLutReadReq_t *inData,
                                             rlTxGainTempLutData_t *outData);

/*TX freq and power limits monitoring configuration */
MMWL_EXPORT rlReturnVal_t rlRfTxFreqPwrLimitConfig(rlUInt8_t deviceMap,
                                                   rlRfTxFreqPwrLimitMonConf_t* data);

/*Looback chirp configuration API */
MMWL_EXPORT rlReturnVal_t rlSetLoopBckBurstCfg(rlUInt8_t deviceMap,
                                               rlLoopbackBurst_t *data);

/*Dynamic chirp configuration API */
MMWL_EXPORT rlReturnVal_t rlSetDynChirpCfg(rlUInt8_t deviceMap,
                                           rlUInt16_t segCnt,
                                           rlDynChirpCfg_t **data);
MMWL_EXPORT rlReturnVal_t rlSetDynChirpEn(rlUInt8_t deviceMap,
                                          rlDynChirpEnCfg_t *data);

/*Dynamic per-chirp phase shifter configuration API(AWR1243P/2243) */
MMWL_EXPORT rlReturnVal_t rlSetDynPerChirpPhShifterCfg(rlUInt8_t deviceMap,
                                                       rlUInt16_t segCnt,
                                                       rlDynPerChirpPhShftCfg_t **data);
/*Calibration data store/restore configuration */
MMWL_EXPORT rlReturnVal_t rlRfCalibDataStore(rlUInt8_t deviceMap,
                                             rlCalibrationData_t *data);
MMWL_EXPORT rlReturnVal_t rlRfCalibDataRestore(rlUInt8_t deviceMap,
                                               rlCalibrationData_t *data);

/*Update Inter Rx Gain/Phase offsets for Inter-RX mismatch compensation */
MMWL_EXPORT rlReturnVal_t rlRfInterRxGainPhaseConfig(rlUInt8_t deviceMap,
                                                     rlInterRxGainPhConf_t* data);

/*Get RadarSS/BSS bootup(Boot time monitoring tests) status */
MMWL_EXPORT rlReturnVal_t rlGetRfBootupStatus(rlUInt8_t deviceMap,
                                              rlRfBootStatusCfg_t *data);

/*Update Inter Rx Gain/Phase offsets for Inter-RX mismatch compensation */
MMWL_EXPORT rlReturnVal_t rlSetInterChirpBlkCtrl(rlUInt8_t deviceMap,
                                                 rlInterChirpBlkCtrlCfg_t *data);
/*Sub frame trigger API */
MMWL_EXPORT rlReturnVal_t rlSetSubFrameStart(rlUInt8_t deviceMap,
                                             rlSubFrameStartCfg_t *data);
/*Phase shifter calibration data store/restore configuration*/
MMWL_EXPORT rlReturnVal_t rlRfPhShiftCalibDataStore(rlUInt8_t deviceMap,
                                                    rlPhShiftCalibrationData_t *data);
MMWL_EXPORT rlReturnVal_t rlRfPhShiftCalibDataRestore(rlUInt8_t deviceMap,
                                                      rlPhShiftCalibrationData_t *data);
/*Get device die ID status*/
MMWL_EXPORT rlReturnVal_t rlGetRfDieId(rlUInt8_t deviceMap, rlRfDieIdCfg_t *data);
/* Get RadarSS CPU/ESM fault status functions */
MMWL_EXPORT rlReturnVal_t rlRfGetEsmFault(rlUInt8_t deviceMap, rlBssEsmFault_t *data);
MMWL_EXPORT rlReturnVal_t rlRfGetCpuFault(rlUInt8_t deviceMap, rlCpuFault_t *data);

/* Advanced Chirp configuration */
MMWL_EXPORT rlReturnVal_t rlSetAdvChirpConfig(rlUInt8_t deviceMap, rlAdvChirpCfg_t *data);

/* Monitor Type Trigger Configuration */
MMWL_EXPORT rlReturnVal_t rlMonTypeTrigConfig(rlUInt8_t deviceMap, rlMonTypeTrigCfg_t *data);

/* APLL and Synthesizer Bandwidth control API */
MMWL_EXPORT rlReturnVal_t rlRfApllSynthBwCtlConfig(rlUInt8_t deviceMap,
                                                 rlRfApllSynthBwControl_t* data);

/* Advanced Chirp LUT Configuration API */
MMWL_EXPORT rlReturnVal_t rlSetAdvChirpLUTConfig(rlUInt8_t deviceMap,
                                                   rlAdvChirpLUTCfg_t* data);

/* Multi Advanced Chirp LUT Configuration API */
MMWL_EXPORT rlReturnVal_t rlSetMultiAdvChirpLUTConfig(rlUInt8_t deviceMap, 
                          rlAdvChirpLUTCfg_t* AdvChirpLUTCfgArgs, rlInt8_t* AdvChirpLUTData);

/* Advanced Chirp Dynamic LUT Address Offset Configuration API */
MMWL_EXPORT rlReturnVal_t rlSetAdvChirpDynLUTAddrOffConfig(rlUInt8_t deviceMap, \
                                            rlAdvChirpDynLUTAddrOffCfg_t *data);

/*!
 Close the Doxygen group.
 @}
 */



#ifdef __cplusplus
}
#endif

#endif
/*
 * END OF RL_SENSOR_H FILE
 */
